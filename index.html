<!DOCTYPE html>
<!-- Tournament App v2.1 -->
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>トーナメント</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --hud-green: #00ff41;
      --hud-green-dim: #00aa2a;
      --hud-green-glow: rgba(0, 255, 65, 0.6);
      --hud-gold: #ffcc00;
      --hud-red: #ff3366;
      --bg-dark: #000a04;
      --bg-panel: rgba(0, 20, 10, 0.85);
      --text-primary: #c0ffc0;
      --text-dim: #4a8a4a;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html {
      overflow: hidden;
      height: 100%;
      position: fixed;
      width: 100%;
    }
    body {
      font-family: 'Noto Sans JP', sans-serif;
      background: #000a04;
      color: var(--text-primary);
      height: 100%;
      overflow: hidden;
      overscroll-behavior: none;
      position: fixed;
      width: 100%;
    }
    .matrix-bg {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
      pointer-events: none;
      overflow: hidden;
    }
    .matrix-col {
      position: absolute;
      top: -100%;
      font-family: 'MS Gothic', monospace;
      font-size: 14px;
      line-height: 1.2;
      color: #00ff41;
      writing-mode: vertical-rl;
      animation: matrix-fall linear infinite;
      opacity: 0.12;
      text-shadow: 0 0 3px #00ff41;
    }
    @keyframes matrix-fall {
      0% { transform: translateY(0); }
      100% { transform: translateY(220vh); }
    }
    .header {
      position: relative;
      z-index: 10;
      display: none;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 2rem;
      background: linear-gradient(180deg, rgba(0,30,15,0.95) 0%, rgba(0,15,8,0.9) 100%);
      border-bottom: 2px solid var(--hud-green);
      box-shadow: 0 0 20px var(--hud-green-glow);
    }
    .header.visible { display: flex; }
    .back-btn {
      background: transparent;
      border: 2px solid var(--hud-green);
      color: var(--hud-green);
      padding: 0.5rem 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      visibility: hidden;
    }
    .back-btn.visible { visibility: visible; }
    .back-btn:hover { background: var(--hud-green); color: var(--bg-dark); box-shadow: 0 0 15px var(--hud-green-glow); }
    .app-title {
      font-family: 'Orbitron', sans-serif;
      font-size: clamp(1.3rem, 4vw, 1.8rem);
      font-weight: 900;
      color: var(--hud-green);
      text-shadow: 0 0 10px var(--hud-green-glow);
      letter-spacing: 0.15em;
    }
    .header-icons { display: flex; gap: 0.8rem; }
    .info-btn {
      background: transparent;
      border: 2px solid var(--hud-green);
      color: var(--hud-green);
      width: 38px; height: 38px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .info-btn:hover { background: var(--hud-green); color: var(--bg-dark); box-shadow: 0 0 15px var(--hud-green-glow); }
    @media (hover: hover) { .info-btn:hover { transform: scale(1.1); } }
    .info-btn.admin-info { border-color: var(--hud-gold); color: var(--hud-gold); }
    .info-btn.admin-info:hover { background: var(--hud-gold); box-shadow: 0 0 15px rgba(255,204,0,0.5); }
    .main-container {
      position: relative;
      z-index: 5;
      height: 100%;
      padding: 1rem;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
    }
    .screen { display: none; overflow: hidden; }
    .screen.active { display: block; height: 100vh; overflow-y: auto; overscroll-behavior: none; }
    .title-screen { height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
    @media (min-width: 900px) {
      .title-screen { flex-direction: row; padding: 2rem; }
    }
    .title-left-menu { display: flex; flex-direction: column; gap: 0.4rem; padding: 1rem; }
    @media (min-width: 900px) {
      .title-left-menu { width: 280px; padding-top: 4rem; }
    }
    .title-center { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem 1rem; }
    .title-right-info { padding: 1rem; }
    @media (min-width: 900px) {
      .title-right-info { width: 300px; padding-top: 4rem; }
    }
    .main-title {
      font-family: 'Times New Roman', 'Georgia', serif;
      font-size: clamp(2.5rem, 10vw, 4.5rem);
      font-weight: bold;
      letter-spacing: 0.25em;
      position: relative;
      display: inline-block;
      color: #b8e6c8;
      background: linear-gradient(
        180deg,
        #3a6a50 0%,
        #5a9a70 10%,
        #8cd4a8 25%,
        #c8f0d8 40%,
        #e8fff0 48%,
        #ffffff 50%,
        #e8fff0 52%,
        #c8f0d8 60%,
        #8cd4a8 75%,
        #5a9a70 90%,
        #3a6a50 100%
      );
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: none;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8)) drop-shadow(0 0 20px rgba(100, 255, 150, 0.3));
      margin-bottom: 0;
    }
    .title-wrapper {
      text-align: center;
      padding: 1.5rem 1rem 1rem;
    }
    .title-guide-icons { position: fixed; top: 1.2rem; right: 1.5rem; display: flex; gap: 0.6rem; z-index: 20; }
    
    /* PC Layout */
    .title-layout {
      display: flex;
      flex-direction: column;
      min-height: calc(100vh - 100px);
    }
    @media (min-width: 900px) {
      .title-layout {
        flex-direction: row;
        padding: 0 2rem;
      }
      .title-layout .left-menu {
        width: 280px;
        flex-shrink: 0;
        padding: 1rem 1rem 1rem 0;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .title-layout .center-content {
        flex: 1;
        padding: 1rem 2rem;
        display: flex;
        flex-direction: column;
      }
    }
    @media (max-width: 899px) {
      .title-layout .left-menu {
        order: 2;
        max-width: 400px;
        margin: 0 auto;
        padding: 0 1rem;
        width: 100%;
      }
      .title-layout .center-content {
        order: 1;
      }
    }
    .hud-panel {
      background: var(--bg-panel);
      border: 2px solid var(--hud-green);
      position: relative;
      padding: 1.2rem;
      clip-path: polygon(0 0, calc(100% - 12px) 0, 100% 12px, 100% 100%, 12px 100%, 0 calc(100% - 12px));
      box-shadow: 0 0 15px var(--hud-green-glow), inset 0 0 30px rgba(0,255,65,0.05);
    }
    .hud-panel-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.85rem;
      color: var(--hud-green);
      letter-spacing: 0.08em;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--hud-green-dim);
    }
    .menu-btn {
      display: block;
      width: 100%;
      background: linear-gradient(90deg, rgba(0,40,20,0.9) 0%, rgba(0,60,30,0.8) 100%);
      border: 2px solid var(--hud-green);
      border-left: 4px solid var(--hud-green);
      color: var(--hud-green);
      padding: 0.9rem 1rem;
      font-size: 0.95rem;
      font-weight: bold;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .menu-btn:hover:not(:disabled) {
      background: linear-gradient(90deg, var(--hud-green) 0%, rgba(0,255,65,0.7) 100%);
      color: var(--bg-dark);
      box-shadow: 0 0 20px var(--hud-green-glow);
      transform: translateX(5px);
    }
    .menu-btn:disabled { opacity: 0.3; cursor: not-allowed; border-color: var(--text-dim); color: var(--text-dim); }
    .menu-btn.cancel-btn { 
      background: linear-gradient(90deg, rgba(40,10,20,0.9) 0%, rgba(60,15,30,0.8) 100%);
      border: 2px solid var(--hud-red); 
      border-left: 4px solid var(--hud-red); 
      color: var(--hud-red);
      margin-top: 1rem;
    }
    .menu-btn.cancel-btn:hover:not(:disabled) { background: linear-gradient(90deg, var(--hud-red) 0%, rgba(255,50,100,0.7) 100%); color: white; box-shadow: 0 0 20px rgba(255,50,100,0.5); }
    .info-display { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.8rem; margin-bottom: 1rem; }
    @media (max-width: 700px) { .info-display { grid-template-columns: repeat(2, 1fr); } }
    .info-item { background: rgba(0,30,15,0.6); border: 1px solid var(--hud-green-dim); padding: 0.6rem; text-align: center; }
    .info-label { font-size: 0.7rem; color: var(--text-dim); margin-bottom: 0.2rem; }
    .info-value { font-family: 'Orbitron', sans-serif; font-size: 0.9rem; color: var(--hud-green); }
    .info-value.warning { color: var(--hud-red); }
    .title-info-panel {
      max-width: 100%;
      margin: 0 0 1.5rem 0;
      background: var(--bg-panel);
      border: 2px solid var(--hud-green);
      padding: 1rem 1.5rem;
    }
    @media (max-width: 899px) {
      .title-info-panel {
        max-width: 800px;
        margin: 0 auto 1.5rem;
      }
    }
    .title-info-panel .hud-panel-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.85rem;
      color: var(--hud-green);
      letter-spacing: 0.08em;
      margin-bottom: 0.8rem;
      padding-bottom: 0.4rem;
      border-bottom: 1px solid var(--hud-green-dim);
      text-align: center;
    }
    .title-info-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
    }
    @media (max-width: 600px) {
      .title-info-grid { grid-template-columns: repeat(2, 1fr); }
    }
    .title-info-item {
      background: rgba(0,40,20,0.5);
      border: 1px solid var(--hud-green-dim);
      padding: 0.8rem;
      text-align: center;
    }
    .title-info-label { font-size: 0.75rem; color: var(--text-dim); margin-bottom: 0.3rem; }
    .title-info-value { font-family: 'Orbitron', sans-serif; font-size: 1rem; color: var(--hud-green); }
    .title-info-value.warning { color: var(--hud-red); }
    .sound-controls {
      position: fixed;
      bottom: 1.5rem;
      left: 1.5rem;
      display: flex;
      gap: 0.5rem;
      z-index: 100;
    }
    .sound-btn {
      background: rgba(0, 20, 10, 0.9);
      border: 1px solid var(--hud-green);
      color: var(--hud-green);
      width: 44px;
      height: 44px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .sound-btn:hover { background: var(--hud-green); color: var(--bg-dark); }
    .sound-btn.off { border-color: var(--text-dim); color: var(--text-dim); opacity: 0.5; }
    .sound-btn.off:hover { background: var(--text-dim); color: white; }
    @media (max-width: 600px) {
      .sound-controls { bottom: 1rem; left: 1rem; }
      .sound-btn { width: 40px; height: 40px; font-size: 1rem; }
    }
    /* 管理者設定2カラムレイアウト */
    .admin-setup-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      max-width: 900px;
      margin: 1.5rem auto;
      padding: 0 0.8rem;
      align-items: start;
    }
    .admin-setup-col { padding: 1rem; }
    .admin-setup-right { display: flex; flex-direction: column; }
    @media (max-width: 700px) {
      .admin-setup-grid { grid-template-columns: 1fr; max-width: 480px; }
    }
    .form-group { margin-bottom: 1.2rem; }
    .form-label { display: block; font-size: 0.8rem; color: var(--text-dim); margin-bottom: 0.4rem; }
    .form-input {
      width: 100%;
      padding: 0.7rem 0.9rem;
      background: rgba(0, 20, 10, 0.9);
      border: 2px solid var(--hud-green-dim);
      color: var(--text-primary);
      font-size: 1rem;
      transition: all 0.2s;
    }
    .form-input:focus { outline: none; border-color: var(--hud-green); box-shadow: 0 0 10px var(--hud-green-glow); }
    .error-message {
      background: rgba(255,50,100,0.2);
      border: 1px solid var(--hud-red);
      color: var(--hud-red);
      padding: 0.4rem;
      margin-top: 0.4rem;
      font-size: 0.8rem;
      display: none;
    }
    .error-message.visible { display: block; }
    .submit-btn {
      width: 100%;
      padding: 0.9rem;
      background: linear-gradient(180deg, rgba(0,60,30,0.9) 0%, rgba(0,40,20,0.95) 100%);
      border: 2px solid var(--hud-green);
      color: var(--hud-green);
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .submit-btn::after { content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 3px; background: var(--hud-green); box-shadow: 0 0 10px var(--hud-green-glow); }
    .submit-btn:hover:not(:disabled) { background: var(--hud-green); color: var(--bg-dark); box-shadow: 0 0 25px var(--hud-green-glow); }
    .submit-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .participant-panel { background: var(--bg-panel); border: 2px solid var(--hud-green); }
    .lottery-sidebar .participant-panel { height: 100%; display: flex; flex-direction: column; }
    .lottery-sidebar .participant-list { flex: 1; max-height: none; overflow-y: auto; }
    @media (min-width: 900px) {
      .lottery-sidebar .participant-list { max-height: 450px; }
    }
    .participant-header { display: flex; justify-content: space-between; align-items: center; padding: 0.8rem 1rem; border-bottom: 1px solid var(--hud-green-dim); }
    .participant-title { font-family: 'Orbitron', sans-serif; color: var(--hud-green); font-size: 0.9rem; }
    .participant-search { padding: 0.4rem 0.6rem; background: rgba(0,20,10,0.8); border: 1px solid var(--hud-green-dim); color: var(--text-primary); font-size: 0.85rem; width: 140px; }
    .participant-list { max-height: 350px; overflow-y: auto; }
    .participant-row { display: grid; grid-template-columns: 55px 35px 1fr 70px; align-items: center; padding: 0.5rem 0.8rem; border-bottom: 1px solid rgba(0,255,65,0.1); font-size: 0.85rem; }
    .participant-row:hover { background: rgba(0,255,65,0.05); }
    .participant-row.header { background: rgba(0,40,20,0.5); font-size: 0.75rem; color: var(--text-dim); }
    .participant-id { font-family: 'Orbitron', sans-serif; color: var(--hud-green); font-size: 0.8rem; }
    .participant-icon { width: 28px; height: 28px; border-radius: 50%; border: 1px solid var(--hud-green); background: var(--bg-dark); display: flex; align-items: center; justify-content: center; overflow: hidden; font-size: 0.8rem; }
    .participant-icon img { width: 100%; height: 100%; object-fit: cover; }
    .status-badge { padding: 0.15rem 0.4rem; font-size: 0.7rem; font-weight: bold; }
    .status-active { background: rgba(0,255,65,0.2); border: 1px solid var(--hud-green); color: var(--hud-green); }
    .status-lost { background: rgba(100,100,100,0.2); border: 1px solid #666; color: #666; }
    .status-seed { background: rgba(255,165,0,0.2); border: 1px solid #ffa500; color: #ffa500; }
    .participant-count { padding: 0.6rem 0.8rem; text-align: right; color: var(--text-dim); font-size: 0.8rem; border-top: 1px solid var(--hud-green-dim); }
    .participant-count span { color: var(--hud-gold); font-weight: bold; }
    .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 5, 2, 0.92); z-index: 1000; align-items: center; justify-content: center; }
    .modal-overlay.active { display: flex; }
    .modal-content { background: var(--bg-panel); border: 2px solid var(--hud-green); padding: 1.5rem; max-width: 450px; width: 90%; position: relative; clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 15px, 100% 100%, 15px 100%, 0 calc(100% - 15px)); box-shadow: 0 0 30px var(--hud-green-glow); }
    .modal-content.guide-modal { max-width: 700px; width: 95%; }
    @media (max-width: 750px) {
      .modal-content.guide-modal { max-width: 95%; }
      .guide-content h4, .guide-content p, .guide-content li { white-space: normal; }
    }
    .modal-close-btn { position: absolute; top: 8px; right: 12px; background: transparent; border: none; color: var(--text-dim); font-size: 1.5rem; cursor: pointer; }
    .modal-close-btn:hover { color: var(--hud-green); }
    .modal-title { font-family: 'Orbitron', sans-serif; color: var(--hud-green); font-size: 1.1rem; text-align: center; margin-bottom: 1.2rem; }
    .modal-buttons { display: flex; gap: 0.8rem; margin-top: 1.2rem; }
    .modal-btn { flex: 1; padding: 0.7rem; font-weight: bold; cursor: pointer; transition: all 0.2s; }
    .modal-btn-cancel { background: transparent; border: 1px solid var(--text-dim); color: var(--text-dim); }
    .modal-btn-cancel:hover { border-color: var(--hud-green); color: var(--hud-green); }
    .modal-btn-confirm { background: var(--hud-green); border: none; color: var(--bg-dark); }
    .modal-btn-confirm:hover { box-shadow: 0 0 20px var(--hud-green-glow); }
    .guide-content { color: var(--text-primary); line-height: 1.7; max-height: 55vh; overflow-y: auto; font-size: 0.9rem; }
    .guide-content h4 { color: var(--hud-green); margin: 1rem 0 0.4rem; font-size: 0.95rem; white-space: nowrap; }
    .guide-content p { color: var(--text-dim); margin-bottom: 0.4rem; white-space: nowrap; }
    .guide-content ul { margin-left: 1rem; color: var(--text-dim); }
    .guide-content li { margin-bottom: 0.3rem; white-space: nowrap; }
    .calendar-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 5, 2, 0.95); z-index: 2000; align-items: center; justify-content: center; }
    .calendar-modal.active { display: flex; }
    .calendar-container { background: var(--bg-panel); border: 2px solid var(--hud-green); padding: 1.2rem; max-width: 340px; width: 95%; box-shadow: 0 0 30px var(--hud-green-glow); position: relative; }
    .calendar-close { position: absolute; top: 8px; right: 10px; background: transparent; border: none; color: var(--text-dim); font-size: 1.3rem; cursor: pointer; }
    .calendar-title { font-family: 'Orbitron', sans-serif; color: var(--hud-green); text-align: center; margin-bottom: 0.8rem; font-size: 1rem; }
    .calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.8rem; }
    .calendar-nav { background: transparent; border: 1px solid var(--hud-green); color: var(--hud-green); width: 32px; height: 32px; cursor: pointer; font-size: 0.9rem; transition: all 0.2s; }
    .calendar-nav:hover { background: var(--hud-green); color: var(--bg-dark); }
    .calendar-month-year { font-family: 'Orbitron', sans-serif; color: var(--hud-green); font-size: 0.95rem; }
    .calendar-weekdays { display: grid; grid-template-columns: repeat(7, 1fr); margin-bottom: 0.3rem; }
    .calendar-weekday { text-align: center; color: var(--text-dim); font-size: 0.75rem; padding: 0.2rem; }
    .calendar-days { display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; }
    .calendar-day { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; background: rgba(0,30,15,0.5); border: 1px solid transparent; color: var(--text-primary); cursor: pointer; font-size: 0.85rem; transition: all 0.2s; }
    .calendar-day:hover:not(.disabled):not(.empty) { border-color: var(--hud-green); background: rgba(0,255,65,0.2); }
    .calendar-day.selected { background: var(--hud-green) !important; color: var(--bg-dark) !important; font-weight: bold; box-shadow: 0 0 10px var(--hud-green-glow); }
    .calendar-day.today:not(.selected) { border-color: var(--hud-gold); }
    .calendar-day.disabled { color: #333; cursor: not-allowed; }
    .calendar-day.empty { background: transparent; cursor: default; }
    .calendar-time { display: flex; justify-content: center; align-items: center; gap: 0.4rem; margin-top: 0.8rem; }
    .calendar-time-input { width: 55px; padding: 0.4rem; background: rgba(0,20,10,0.8); border: 1px solid var(--hud-green-dim); color: var(--text-primary); text-align: center; font-size: 1rem; }
    .calendar-selected-display { text-align: center; color: var(--hud-gold); margin-top: 0.8rem; padding: 0.4rem; background: rgba(255,204,0,0.1); border: 1px solid var(--hud-gold); font-size: 0.9rem; }
    .calendar-confirm { width: 100%; margin-top: 0.8rem; padding: 0.7rem; background: var(--hud-green); border: none; color: var(--bg-dark); font-weight: bold; cursor: pointer; }
    .calendar-confirm:hover { box-shadow: 0 0 20px var(--hud-green-glow); }
    .toast { position: fixed; bottom: 1.5rem; left: 50%; transform: translateX(-50%) translateY(100px); padding: 0.8rem 1.5rem; font-weight: bold; z-index: 3000; transition: transform 0.3s; border: 2px solid; font-size: 0.9rem; }
    .toast.visible { transform: translateX(-50%) translateY(0); }
    .toast.success { background: rgba(0,40,20,0.95); border-color: var(--hud-green); color: var(--hud-green); }
    .toast.error { background: rgba(40,10,20,0.95); border-color: var(--hud-red); color: var(--hud-red); }
    .my-entry-box { background: rgba(0,255,65,0.1); border: 2px solid var(--hud-green); padding: 1.2rem; text-align: center; }
    .my-entry-title { color: var(--hud-green); font-size: 1rem; margin-bottom: 0.8rem; }
    .my-entry-info { font-size: 1.1rem; color: var(--text-primary); }
    .my-entry-id { color: var(--hud-gold); font-weight: bold; }
    /* 抽選会場へボタン */
    .lottery-venue-btn {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      gap: 0.3rem;
      padding: 1.2rem 2.5rem;
      background: rgba(0, 40, 20, 0.9);
      border: 2px solid var(--hud-green-dim);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
    }
    .lottery-venue-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .lottery-venue-btn:not(:disabled) {
      border-color: var(--hud-green);
      box-shadow: 0 0 20px var(--hud-green-glow), inset 0 0 20px rgba(0, 255, 65, 0.1);
      animation: lottery-pulse 2s infinite;
    }
    .lottery-venue-btn:not(:disabled):hover {
      box-shadow: 0 0 30px var(--hud-green-glow), inset 0 0 30px rgba(0, 255, 65, 0.2);
    }
    @media (hover: hover) {
      .lottery-venue-btn:not(:disabled):hover { transform: scale(1.05); }
    }
    @keyframes lottery-pulse {
      0%, 100% { box-shadow: 0 0 20px var(--hud-green-glow); }
      50% { box-shadow: 0 0 35px var(--hud-green-glow), 0 0 50px rgba(0, 255, 65, 0.3); }
    }
    .lottery-icon { font-size: 2rem; }
    .lottery-text { font-family: 'Orbitron', sans-serif; font-size: 1.2rem; color: var(--hud-green); font-weight: bold; }
    .lottery-sub { font-size: 0.75rem; color: var(--text-dim); }
    .lottery-venue-btn:not(:disabled) .lottery-sub { display: none; }

    /* ゲーム選択エリア */
    .game-select-area {
      margin: 0.5rem 0;
      width: 100%;
      max-width: 280px;
    }
    @media (min-width: 900px) {
      .game-select-area {
        margin: 0;
        flex-shrink: 0;
        width: 240px;
        max-width: 240px;
      }
    }
    .game-select-wrapper {
      position: relative;
    }
    .game-select-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.45rem 1rem;
      background: rgba(0, 30, 15, 0.9);
      border: 1px solid var(--hud-green-dim);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .game-select-header:hover {
      border-color: var(--hud-green);
      box-shadow: 0 0 12px var(--hud-green-glow);
    }
    .game-select-icon { font-size: 0.9rem; }
    .game-select-label {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      color: var(--hud-green);
      letter-spacing: 0.05em;
    }
    .game-select-arrow {
      font-size: 0.55rem;
      color: var(--hud-green-dim);
      transition: transform 0.3s;
    }
    .game-select-arrow.open { transform: rotate(180deg); }
    .game-select-panel {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      margin-top: 4px;
      border: 1px solid var(--hud-green-dim);
      border-radius: 6px;
      background: rgba(0, 20, 10, 0.97);
      overflow: hidden;
      z-index: 50;
      animation: gameSelectSlide 0.2s ease-out;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
    }
    @keyframes gameSelectSlide {
      from { opacity: 0; transform: translateY(-6px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .game-select-list {
      padding: 0.3rem;
      max-height: 200px;
      overflow-y: auto;
    }
    .game-select-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.7rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
    }
    .game-select-item:hover {
      background: rgba(0, 255, 65, 0.08);
      border-color: var(--hud-green-dim);
    }
    .game-select-item:active {
      background: rgba(0, 255, 65, 0.15);
    }
    .game-select-item.disabled {
      opacity: 0.35;
      cursor: not-allowed;
      pointer-events: none;
    }
    .game-select-item-icon {
      width: 24px;
      height: 24px;
      border: 1px solid var(--hud-green-dim);
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 40, 20, 0.6);
      font-size: 0.75rem;
      flex-shrink: 0;
    }
    .game-select-item-name {
      flex: 1;
      font-size: 0.8rem;
      color: var(--hud-green);
    }
    .game-select-item.disabled .game-select-item-name {
      color: var(--text-dim);
    }
    .game-select-item-badge {
      font-size: 0.55rem;
      color: var(--bg-dark);
      background: var(--hud-green);
      padding: 0.1rem 0.35rem;
      border-radius: 3px;
      font-weight: bold;
    }
    .game-select-item-tag {
      font-size: 0.6rem;
      color: var(--text-dim);
    }

    /* 抽選会場レイアウト */
    .lottery-arena {
      display: none;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }
    .lottery-arena.active { display: block; }
    
    @media (min-width: 900px) {
      .lottery-arena {
        display: none;
        grid-template-columns: 1fr 350px;
        gap: 1.5rem;
      }
      .lottery-arena.active { display: grid; }
    }
    
    /* 左側：ルーレット＋VS */
    .lottery-main {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    @media (min-width: 900px) {
      .lottery-main {
        align-items: flex-start;
      }
    }
    .lottery-main-top {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }
    @media (min-width: 900px) {
      .lottery-main-top {
        flex-direction: row;
        align-items: flex-start;
        gap: 1.5rem;
      }
    }
    
    .roulette-container { 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      position: relative;
    }
    .roulette-wheel { 
      width: 280px; 
      height: 280px; 
      border: 4px solid var(--hud-green); 
      border-radius: 50%; 
      position: relative; 
      background: radial-gradient(circle, rgba(0,60,30,0.9) 0%, rgba(0,20,10,0.95) 70%, var(--bg-dark) 100%); 
      box-shadow: 0 0 40px var(--hud-green-glow), inset 0 0 60px rgba(0,255,65,0.1);
    }
    @media (min-width: 900px) {
      .roulette-wheel {
        width: 520px;
        height: 520px;
        border-width: 5px;
      }
    }
    .wheel-inner { width: 100%; height: 100%; transition: transform 4s cubic-bezier(0.17,0.67,0.12,0.99); }
    .wheel-segment { 
      position: absolute; 
      width: 100%; 
      height: 100%; 
      display: flex; 
      align-items: flex-start; 
      justify-content: center; 
      padding-top: 15px; 
      font-family: 'Orbitron', sans-serif; 
      font-size: 0.85rem; 
      color: var(--hud-green); 
      text-shadow: 0 0 8px var(--hud-green-glow);
    }
    @media (min-width: 900px) {
      .wheel-segment { font-size: 1rem; padding-top: 20px; }
    }
    
    /* VS表示（ルーレット中央に重ねる） */
    .vs-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      text-align: center;
      pointer-events: none;
    }
    .vs-display { 
      background: rgba(0, 20, 10, 0.95); 
      border: 3px solid var(--hud-green); 
      border-radius: 12px;
      padding: 1rem 1.5rem; 
      text-align: center;
      box-shadow: 0 0 30px rgba(0,0,0,0.8);
    }
    @media (min-width: 900px) {
      .vs-display { padding: 1.5rem 2rem; }
    }
    .vs-title { color: var(--hud-gold); font-size: 0.9rem; margin-bottom: 0.8rem; font-weight: bold; }
    .vs-players { display: flex; align-items: center; justify-content: center; gap: 1rem; }
    @media (min-width: 900px) {
      .vs-players { gap: 1.5rem; }
    }
    .vs-player { text-align: center; transition: all 0.3s; }
    .vs-player.clickable { cursor: pointer; }
    .vs-player.clickable:hover {
      filter: drop-shadow(0 0 10px var(--hud-gold));
    }
    @media (hover: hover) {
      .vs-player.clickable:hover { transform: scale(1.1); }
    }
    .vs-player.winner-selected {
      background: rgba(0, 255, 65, 0.3);
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
    }
    .vs-player-icon { 
      width: 60px; 
      height: 60px; 
      border-radius: 50%; 
      border: 3px solid var(--hud-green); 
      margin: 0 auto 0.5rem; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      background: var(--bg-dark); 
      overflow: hidden;
      font-size: 1.5rem;
    }
    @media (min-width: 900px) {
      .vs-player-icon { width: 90px; height: 90px; font-size: 2.2rem; }
    }
    .silhouette-icon { width: 60%; height: 60%; }
    .silhouette-icon circle, .silhouette-icon path { fill: var(--hud-green); opacity: 0.5; }
    .vs-player-id { color: var(--text-dim); font-size: 0.8rem; font-family: 'Orbitron', sans-serif; }
    .vs-player-name { 
      color: var(--hud-green); 
      font-weight: bold; 
      font-size: 1rem; 
      max-width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    @media (min-width: 900px) {
      .vs-player-name { font-size: 1.2rem; max-width: 120px; }
    }
    .vs-text { 
      font-family: 'Orbitron', sans-serif; 
      font-size: 2rem; 
      color: var(--hud-gold); 
      text-shadow: 0 0 15px rgba(255,204,0,0.7);
      animation: vs-pulse 1.5s infinite;
    }
    @media (min-width: 900px) {
      .vs-text { font-size: 2.5rem; }
    }
    @keyframes vs-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    /* 操作ボタン */
    .roulette-controls {
      display: flex;
      gap: 0.8rem;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 1.5rem;
    }
    @media (min-width: 900px) {
      .roulette-controls {
        justify-content: center;
        width: 520px;
        align-self: flex-start;
      }
    }
    .roulette-btn { 
      padding: 0.9rem 1.5rem; 
      font-weight: bold; 
      cursor: pointer; 
      transition: all 0.2s; 
      font-size: 1rem;
      border-radius: 6px;
    }
    .roulette-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    #spinBtn { background: var(--hud-green); border: none; color: var(--bg-dark); }
    #spinBtn:hover:not(:disabled) { box-shadow: 0 0 20px var(--hud-green-glow); }
    
    /* 勝者選択ボタン */
    .winner-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.3rem;
      padding: 1rem 1.5rem !important;
      min-width: 140px;
    }
    .winner-btn:hover { box-shadow: 0 0 20px var(--hud-green-glow); }
    @media (hover: hover) { .winner-btn:hover { transform: scale(1.05); } }
    .winner-label { font-size: 0.8rem; color: var(--hud-gold); }
    .winner-name { font-size: 1.1rem; font-weight: bold; color: var(--hud-green); }
    
    /* マッチング中のハイライト */
    .participant-row.matching {
      background: rgba(0, 255, 65, 0.15) !important;
      border-left: 3px solid var(--hud-green);
      animation: matching-pulse 1.5s infinite;
    }
    @keyframes matching-pulse {
      0%, 100% { background: rgba(0, 255, 65, 0.1); }
      50% { background: rgba(0, 255, 65, 0.2); }
    }
    
    /* 現在のマッチ表示 */
    .current-match-display {
      background: rgba(0, 40, 20, 0.9);
      border: 2px solid var(--hud-gold);
      padding: 1rem;
      margin-bottom: 1rem;
      text-align: center;
    }
    .current-match-title { color: var(--hud-gold); font-size: 0.85rem; margin-bottom: 0.5rem; }
    .current-match-vs { 
      font-family: 'Orbitron', sans-serif; 
      color: var(--hud-green); 
      font-size: 1rem;
    }
    .current-match-vs span { color: var(--hud-gold); margin: 0 0.5rem; }
    
    /* トーナメント表 - ツリー型ブラケット */
    .bracket-container {
      display: none;
      flex-direction: column;
      align-items: center;
      padding: 1rem 0.5rem 2rem;
      overflow-x: auto;
      overflow-y: auto;
      width: 100%;
      -webkit-overflow-scrolling: touch;
    }
    @media (min-width: 900px) {
      .bracket-container { padding: 1.5rem 1rem; min-height: 60vh; }
    }
    .bracket-container.active { display: flex; }

    .bracket-title {
      font-family: 'Orbitron', sans-serif;
      color: var(--hud-gold);
      font-size: 1.1rem;
      margin-bottom: 1rem;
      text-align: center;
      text-shadow: 0 0 10px rgba(255,204,0,0.5);
    }
    @media (min-width: 900px) {
      .bracket-title { font-size: 1.3rem; margin-bottom: 1.5rem; }
    }
    
    /* スクロールヒント（スマホ用） */
    .bracket-scroll-hint {
      display: none;
      text-align: center;
      color: var(--text-dim);
      font-size: 0.7rem;
      margin-bottom: 0.5rem;
      animation: hint-fade 2s infinite;
    }
    @keyframes hint-fade {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }
    /* グループタブ */
    .group-tabs-container {
      padding: 0.5rem;
      border-bottom: 1px solid rgba(0,255,65,0.15);
      margin-bottom: 0.5rem;
    }
    .group-tabs {
      display: flex;
      gap: 0.4rem;
      justify-content: center;
      flex-wrap: wrap;
    }
    .group-tab {
      padding: 0.4rem 0.8rem;
      border: 1px solid var(--hud-green-dim);
      background: rgba(0, 20, 10, 0.6);
      color: var(--hud-green-dim);
      cursor: pointer;
      font-family: 'Orbitron', monospace;
      font-size: 0.7rem;
      transition: all 0.3s;
      border-radius: 2px;
    }
    .group-tab:hover {
      border-color: var(--hud-green);
      color: var(--hud-green);
    }
    .group-tab.active {
      border-color: var(--hud-green);
      color: var(--hud-green);
      background: rgba(0, 255, 65, 0.1);
      box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
    }
    .group-tab.completed {
      border-color: var(--hud-gold);
      color: var(--hud-gold);
    }
    .group-tab.finals-tab {
      border-color: var(--hud-gold);
      color: var(--hud-gold);
      font-weight: 700;
    }
    .group-tab.finals-tab.active {
      background: rgba(255, 204, 0, 0.1);
      box-shadow: 0 0 10px rgba(255, 204, 0, 0.3);
    }
    .group-info-text {
      text-align: center;
      font-size: 0.75rem;
      color: var(--text-dim);
      margin-top: 0.4rem;
    }
    .bulk-match-btn {
      display: inline-block;
      padding: 0.5rem 1.5rem;
      border: 1px solid var(--hud-green);
      background: rgba(0, 40, 20, 0.8);
      color: var(--hud-green);
      font-family: 'Orbitron', monospace;
      font-size: 0.8rem;
      cursor: pointer;
      margin-top: 0.5rem;
      transition: all 0.3s;
    }
    .bulk-match-btn:hover {
      background: rgba(0, 255, 65, 0.15);
      box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
    }

    /* トーナメントブラケット - 伝統的な形式 */
    .bracket-tree {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
      min-width: fit-content;
      position: relative;
    }
    @media (min-width: 900px) {
      .bracket-tree { padding: 1rem; }
    }
    
    /* SVG線のコンテナ */
    .bracket-lines {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .bracket-line {
      stroke: var(--hud-green-dim);
      stroke-width: 2;
      fill: none;
      opacity: 0.3;
    }

    .bracket-line.winner {
      stroke: var(--hud-green);
      stroke-width: 3;
      opacity: 1;
      filter: drop-shadow(0 0 6px var(--hud-green-glow));
      animation: line-glow 2s infinite;
    }

    @keyframes line-glow {
      0%, 100% { filter: drop-shadow(0 0 6px var(--hud-green-glow)); }
      50% { filter: drop-shadow(0 0 12px rgba(0, 255, 65, 1)); }
    }
    
    /* 優勝枠（最上部） */
    .bracket-champion-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.8rem 1.5rem;
      border: 3px solid var(--hud-gold);
      background: rgba(255, 204, 0, 0.15);
      animation: champion-glow 2s infinite;
      margin-bottom: 0;
      z-index: 10;
      position: relative;
    }
    @keyframes champion-glow {
      0%, 100% { box-shadow: 0 0 15px rgba(255,204,0,0.3); }
      50% { box-shadow: 0 0 30px rgba(255,204,0,0.6); }
    }
    .bracket-champion-box.empty {
      border-style: dashed;
      animation: none;
      opacity: 0.6;
    }
    .champion-trophy { font-size: 1.5rem; }
    .champion-label { font-size: 0.7rem; color: var(--hud-gold); }
    .champion-name {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      color: var(--hud-gold);
    }
    .bracket-champion-box.empty .champion-name { color: var(--text-dim); }
    
    /* ラウンドのコンテナ */
    .bracket-rounds {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
      width: 100%;
      position: relative;
      z-index: 5;
    }
    
    /* ラウンド行 */
    .bracket-round-row {
      display: flex;
      justify-content: center;
      gap: 15px;
      position: relative;
    }
    
    /* プレイヤーボックス（下部に横並び） */
    .bracket-player-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 50px;
      min-height: 80px;
      padding: 8px 4px;
      background: rgba(0, 30, 15, 0.9);
      border: 2px solid var(--hud-green-dim);
      cursor: default;
      transition: all 0.3s;
      position: relative;
      z-index: 10;
    }
    @media (min-width: 900px) {
      .bracket-player-box { width: 60px; min-height: 100px; }
    }
    
    .bracket-player-box.clickable { cursor: pointer; }
    .bracket-player-box.clickable:hover {
      background: rgba(0, 255, 65, 0.2);
    }
    @media (hover: hover) {
      .bracket-player-box.clickable:hover { transform: scale(1.05); }
    }
    .bracket-player-box.winner {
      background: rgba(0, 255, 65, 0.15);
      border-color: var(--hud-green);
      box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
    }
    .bracket-player-box.loser {
      opacity: 0.4;
      border-color: #333;
    }
    .bracket-player-box.seed {
      border-left: 3px solid #ffa500;
    }
    .bracket-player-box.active {
      animation: pulse-active 1.5s infinite;
    }
    @keyframes pulse-active {
      0%, 100% { box-shadow: 0 0 5px rgba(255, 204, 0, 0.3); }
      50% { box-shadow: 0 0 15px rgba(255, 204, 0, 0.6); }
    }
    
    .bracket-player-box.empty {
      border-style: dashed;
      opacity: 0.5;
    }
    .bracket-vs-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 204, 0, 0.15);
      border: 2px solid var(--hud-gold);
      border-radius: 50%;
      color: var(--hud-gold);
      font-weight: bold;
      transition: all 0.2s;
      animation: pulse-active 1.5s infinite;
    }
    .bracket-vs-btn:hover {
      background: rgba(255, 204, 0, 0.4);
    }
    @media (hover: hover) {
      .bracket-vs-btn:hover { transform: scale(1.15); }
    }
    .bracket-player-box.empty .player-name-v {
      color: var(--text-dim);
    }
    
    /* 名前縦書き */
    .player-name-v {
      writing-mode: vertical-rl;
      text-orientation: upright;
      font-size: 0.7rem;
      color: var(--hud-green);
      letter-spacing: 2px;
      max-height: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    @media (min-width: 900px) {
      .player-name-v { font-size: 0.8rem; max-height: 80px; }
    }
    .bracket-player-box.loser .player-name-v {
      color: #555;
      text-decoration: line-through;
    }
    .bracket-player-box.winner .player-name-v {
      color: var(--hud-gold);
    }

    /* 上位ラウンドの対戦ボックス */
    .bracket-upper-match {
      display: flex;
      gap: 4px;
      align-items: stretch;
      z-index: 15;
      pointer-events: auto;
    }
    .bracket-upper-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 30, 15, 0.95);
      border: 2px solid var(--hud-green-dim);
      padding: 2px 3px;
      transition: all 0.3s;
      cursor: default;
      position: relative;
    }
    .bracket-upper-box .upper-name {
      writing-mode: vertical-rl;
      text-orientation: upright;
      font-size: 0.6rem;
      color: var(--hud-green);
      letter-spacing: 1px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .bracket-upper-box.clickable { cursor: pointer; }
    .bracket-upper-box.clickable:hover {
      background: rgba(0, 255, 65, 0.25);
      box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
    }
    @media (hover: hover) {
      .bracket-upper-box.clickable:hover { transform: scale(1.1); }
    }
    .bracket-upper-box.winner {
      background: rgba(0, 255, 65, 0.15);
      border-color: var(--hud-green);
      box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
    }
    .bracket-upper-box.winner .upper-name {
      color: var(--hud-gold);
    }
    .bracket-upper-box.loser {
      opacity: 0.4;
      border-color: #333;
    }
    .bracket-upper-box.loser .upper-name {
      color: #555;
      text-decoration: line-through;
    }
    .bracket-upper-box.active {
      animation: pulse-active 1.5s infinite;
    }
    .bracket-upper-box.empty .upper-name {
      color: var(--text-dim);
    }

    .player-id-v {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.5rem;
      color: var(--text-dim);
      margin-top: 5px;
    }
    
    .winner-mark, .seed-mark {
      font-size: 0.6rem;
      margin-bottom: 3px;
    }
    
    /* ラウンドラベル */
    .bracket-round-label {
      position: absolute;
      left: -80px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.7rem;
      color: var(--text-dim);
      white-space: nowrap;
    }
    
    /* トーナメント表へボタン */
    .bracket-view-btn {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.6rem 1rem;
      background: rgba(0, 40, 20, 0.9);
      border: 2px solid var(--hud-gold);
      color: var(--hud-gold);
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.8rem;
      margin: 0.3rem;
    }
    @media (min-width: 900px) {
      .bracket-view-btn { padding: 0.8rem 1.5rem; font-size: 0.9rem; gap: 0.5rem; margin: 0.5rem; }
    }
    .bracket-view-btn:hover { box-shadow: 0 0 15px rgba(255,204,0,0.4); }
    .bracket-view-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    /* 対戦カード抽選ボタン - 有効化時 */
    .matchmaking-active {
      background: linear-gradient(180deg, rgba(0,60,30,0.9) 0%, rgba(0,40,20,0.95) 100%) !important;
      border: 2px solid var(--hud-green) !important;
      color: var(--hud-green) !important;
      font-weight: bold;
      animation: matchmaking-glow 1.5s ease-in-out infinite;
      box-shadow: 0 0 15px var(--hud-green-glow), inset 0 0 15px rgba(0, 255, 65, 0.1);
    }
    .matchmaking-active:hover {
      background: var(--hud-green) !important;
      color: var(--bg-dark) !important;
      box-shadow: 0 0 30px var(--hud-green-glow);
    }
    @keyframes matchmaking-glow {
      0%, 100% { box-shadow: 0 0 15px var(--hud-green-glow), inset 0 0 15px rgba(0, 255, 65, 0.1); }
      50% { box-shadow: 0 0 30px var(--hud-green-glow), 0 0 50px rgba(0, 255, 65, 0.2), inset 0 0 20px rgba(0, 255, 65, 0.15); }
    }
    
    /* 右側：参加者リスト */
    .lottery-sidebar {
      margin-top: 1.5rem;
    }
    @media (min-width: 900px) {
      .lottery-sidebar { margin-top: 0; }
    }
    
    .history-card { background: var(--bg-panel); border: 1px solid var(--hud-green-dim); padding: 1rem; margin-bottom: 0.8rem; }
    .history-date { color: var(--text-dim); font-size: 0.8rem; }
    .history-game { color: var(--hud-green); font-size: 1.1rem; font-weight: bold; margin: 0.4rem 0; }
    .history-winner { color: var(--hud-gold); }
    .participant-status {
      text-align: center;
      padding: 2rem 1rem;
      margin-top: 1.5rem;
    }
    @media (min-width: 900px) {
      .participant-status {
        text-align: left;
        padding: 1rem 0;
      }
    }
    .participant-status-main {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      color: var(--hud-green);
      margin-bottom: 0.3rem;
    }
    @media (min-width: 900px) {
      .participant-status-main { font-size: 1.1rem; }
    }
    .participant-status-main span {
      color: var(--hud-gold);
      font-weight: bold;
    }
    .participant-status-sub {
      font-size: 0.7rem;
      color: var(--text-dim);
      line-height: 1.5;
    }
    
    /* HUD - リアルタイム情報エリア */
    .hud-info-panel {
      position: fixed;
      bottom: 1.5rem;
      left: 320px;
      right: 2rem;
      background: rgba(0, 15, 8, 0.85);
      border: 1px solid var(--hud-green-dim);
      border-radius: 8px;
      padding: 1.2rem 1.5rem;
      z-index: 50;
      display: none;
    }
    /* タイトル画面がアクティブな時のみPC表示 */
    @media (min-width: 900px) {
      #titleScreen.active ~ .hud-info-panel,
      .hud-info-panel.title-active { display: block; }
    }
    .hud-info-panel::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      border-radius: 8px;
      box-shadow: inset 0 0 20px rgba(0, 255, 65, 0.05);
      pointer-events: none;
    }
    .hud-content {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    /* 状態バー（上部横長） */
    .hud-status-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(0, 30, 15, 0.6);
      border: 1px solid var(--hud-green);
      border-radius: 4px;
      padding: 0.8rem 1.5rem;
    }
    .hud-status-left {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }
    .hud-status-title {
      font-size: 0.8rem;
      color: var(--text-dim);
      letter-spacing: 0.05em;
    }
    .hud-status-list {
      display: flex;
      gap: 0.6rem;
    }
    .hud-status-item {
      font-size: 0.85rem;
      padding: 0.4rem 1rem;
      border: 1px solid var(--text-dim);
      color: var(--text-dim);
      border-radius: 3px;
      transition: all 0.3s;
    }
    .hud-status-item.active {
      border-color: var(--hud-green);
      color: var(--hud-green);
      box-shadow: 0 0 8px var(--hud-green-glow);
      text-shadow: 0 0 5px var(--hud-green-glow);
    }
    .hud-next-event {
      font-size: 0.9rem;
      color: var(--hud-gold);
    }
    .hud-system-notice {
      font-size: 0.8rem;
      color: var(--hud-red);
      margin-left: 1rem;
    }
    /* ログエリア（下部） */
    .hud-log-area {
      flex: 1;
      min-width: 0;
    }
    .hud-log-title {
      font-size: 0.8rem;
      color: var(--text-dim);
      margin-bottom: 0.6rem;
      letter-spacing: 0.05em;
    }
    .hud-log-list {
      height: 250px;
      overflow: hidden;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    .hud-log-item {
      color: var(--text-primary);
      padding: 0.2rem 0;
      opacity: 1;
      transition: opacity 0.3s;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .hud-log-item.fade-in {
      animation: logFadeIn 0.3s ease;
    }
    .hud-log-item.fade-out {
      opacity: 0;
    }
    .hud-log-item .log-time {
      color: var(--text-dim);
      margin-right: 0.6rem;
      font-size: 0.8rem;
    }
    @keyframes logFadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* スマホ用HUD */
    .hud-mobile {
      display: none;
      background: rgba(0, 15, 8, 0.9);
      border: 1px solid var(--hud-green-dim);
      border-radius: 6px;
      padding: 0.8rem 1rem;
      margin-top: 1rem;
    }
    @media (max-width: 899px) {
      .hud-mobile { display: block; }
    }
    .hud-mobile .hud-status-bar {
      flex-direction: column;
      gap: 0.5rem;
      padding: 0.5rem 0.8rem;
      margin-bottom: 0.8rem;
    }
    .hud-mobile .hud-status-left {
      flex-direction: column;
      gap: 0.5rem;
    }
    .hud-mobile .hud-status-list {
      justify-content: center;
      flex-wrap: wrap;
    }
    .hud-mobile .hud-next-event {
      text-align: center;
      font-size: 0.75rem;
    }
    .hud-mobile .hud-log-list {
      height: 60px;
      font-size: 0.7rem;
    }
    .hud-mobile .hud-log-title {
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="matrix-bg" id="matrixBg"></div>
  <header class="header" id="mainHeader">
    <button class="back-btn" id="backBtn" onclick="goBack()">◀ 戻る</button>
    <h1 class="app-title">トーナメント</h1>
    <div class="header-icons">
      <button class="info-btn" onclick="showGuide('user')">?</button>
      <button class="info-btn admin-info" onclick="showGuide('admin')">👑</button>
    </div>
  </header>
  <div class="main-container">
    <div class="screen active" id="titleScreen">
      <div class="title-guide-icons">
        <button class="info-btn" onclick="showGuide('user')">?</button>
        <button class="info-btn admin-info" onclick="showGuide('admin')">👑</button>
      </div>
      
      <!-- タイトル（上部） -->
      <div class="title-wrapper">
        <h1 class="main-title">トーナメント</h1>
      </div>
      
      <!-- PC: 左メニュー + 中央コンテンツ / スマホ: 縦積み -->
      <div class="title-layout">
        <!-- 左メニュー（PC時）/ 下部メニュー（スマホ時） -->
        <div class="left-menu">
          <button class="menu-btn" id="entryBtn" onclick="navigateTo('entryScreen')" disabled>エントリー登録する</button>
          <button class="menu-btn" id="viewTournamentBtn" onclick="navigateTo('tournamentScreen')">トーナメントを見る</button>
          <button class="menu-btn" onclick="navigateTo('historyScreen')">過去の大会記録を見る</button>
          <button class="menu-btn" id="adminRegisterBtn" onclick="goToAdminScreen()">管理者登録をする</button>
          <button class="menu-btn cancel-btn" id="cancelEntryBtn" onclick="cancelEntry()" disabled>登録解除</button>
          
          <!-- 参加者数表示（メニュー下） -->
          <div class="participant-status" style="margin-top:1.5rem;padding:1rem 0;">
            <div class="participant-status-main">参加者数：<span id="titleParticipantCount">0</span>/100</div>
            <div class="participant-status-sub">※最大100人・上限で締切</div>
          </div>
        </div>
        
        <!-- 中央コンテンツ -->
        <div class="center-content">
          <!-- 大会情報（横長） -->
          <div class="title-info-panel">
            <div class="hud-panel-title">◆ 大会情報</div>
            <div class="title-info-grid">
              <div class="title-info-item"><div class="title-info-label">ゲーム名</div><div class="title-info-value" id="titleGameName">未設定</div></div>
              <div class="title-info-item"><div class="title-info-label">締切日時</div><div class="title-info-value" id="titleDeadline">未設定</div></div>
              <div class="title-info-item"><div class="title-info-label">管理者</div><div class="title-info-value" id="titleAdmin">-</div></div>
              <div class="title-info-item"><div class="title-info-label">参加者</div><div class="title-info-value" id="titleCount">0名</div></div>
            </div>
          </div>
          
          <!-- スマホ用HUD（モバイル時のみ表示） -->
          <div class="hud-mobile" id="hudMobile">
            <div class="hud-status-bar">
              <div class="hud-status-left">
                <span class="hud-status-title">▶ ステータス</span>
                <div class="hud-status-list">
                  <span class="hud-status-item active" id="statusReceptionMobile">受付中</span>
                  <span class="hud-status-item" id="statusClosedMobile">受付終了</span>
                  <span class="hud-status-item" id="statusProgressMobile">進行中</span>
                  <span class="hud-status-item" id="statusEndMobile">終了</span>
                </div>
              </div>
              <div class="hud-next-event" id="hudNextEventMobile"></div>
            </div>
            <div class="hud-log-title">▶ リアルタイムログ</div>
            <div class="hud-log-list" id="hudLogListMobile"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="screen" id="adminScreen">
      <div class="hud-panel" style="max-width:480px;margin:2rem auto;">
        <div class="hud-panel-title">◆ 管理者登録</div>
        <p style="margin-bottom:1.2rem;color:var(--text-dim);font-size:0.9rem;">管理者として登録すると、大会の設定・運営が可能になります。</p>
        <div class="form-group">
          <label class="form-label">管理者名</label>
          <input type="text" class="form-input" id="adminNameInput" placeholder="管理者名を入力" maxlength="20">
          <div class="error-message" id="adminNameError"></div>
        </div>
        <button class="submit-btn" onclick="registerAdmin()">管理者として登録</button>
      </div>
    </div>
    <div class="screen" id="adminSetupScreen">
      <div class="admin-setup-grid">
        <!-- 左カラム：大会設定 -->
        <div class="hud-panel admin-setup-col">
          <div class="hud-panel-title">◆ 大会設定</div>
          <p style="margin-bottom:0.8rem;color:var(--text-dim);font-size:0.85rem;">締切日時を設定すると、参加者がエントリーできるようになります。</p>
          <div class="form-group">
            <label class="form-label">ゲーム名（大会名）<span style="color:var(--hud-red);"> *必須</span></label>
            <input type="text" class="form-input" id="setupGameName" placeholder="例: スマブラSP大会">
            <div class="error-message" id="setupGameNameError"></div>
          </div>
          <div class="form-group">
            <label class="form-label">エントリー締切日時 <span style="color:var(--hud-red);">*必須</span></label>
            <button type="button" class="form-input" id="setupDeadlineBtn" onclick="openCalendar('setup')" style="text-align:left;cursor:pointer;">クリックして日時を選択</button>
            <input type="hidden" id="setupDeadline">
            <div class="error-message" id="setupDeadlineError"></div>
          </div>
          <div class="form-group">
            <label class="form-label">対戦相手を決める</label>
            <button type="button" class="form-input" id="matchmakingBtn" onclick="showMatchmakingInfo()" style="text-align:center;cursor:pointer;opacity:0.5;">🎲 対戦カード抽選（締切後に有効化）</button>
            <p style="font-size:0.75rem;color:var(--text-dim);margin-top:0.4rem;">※締切日時以降に有効化されます</p>
          </div>
          <button class="submit-btn" onclick="saveTournamentSettings()">設定を保存</button>
          <div style="margin-top:1.2rem;padding-top:1rem;border-top:1px solid var(--hud-green-dim);margin-bottom:0.5rem;">
            <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:0.6rem;">⚠️ 管理者専用</p>
            <button id="resetTournamentBtn" onclick="confirmResetTournament()" style="width:100%;padding:0.9rem;background:rgba(40,10,20,0.8);border:2px solid var(--hud-red);color:var(--hud-red);font-size:1rem;font-weight:bold;cursor:pointer;transition:all 0.2s;">管理者登録解除・大会リセット</button>
            <p style="font-size:0.7rem;color:var(--text-dim);margin-top:0.4rem;">※締切日時以降は大会終了まで使用不可</p>
          </div>
        </div>

        <!-- 右カラム：ゲーム登録 -->
        <div class="admin-setup-right">
          <div class="hud-panel admin-setup-col">
            <div class="hud-panel-title" style="font-size:0.95rem;">◇ ゲーム登録</div>
            <p style="font-size:0.75rem;color:var(--hud-green);margin-bottom:0.3rem;">※大会を開かなくても、いつでもゲームを追加できます</p>
            <p style="font-size:0.7rem;color:var(--text-dim);margin-bottom:0.6rem;">登録したゲームは抽選会場のドロップダウンに表示されます。</p>
            <div class="form-group">
              <label class="form-label">ゲーム名</label>
              <input type="text" class="form-input" id="gameRegName" placeholder="例: スマブラSP" maxlength="30">
            </div>
            <div class="form-group">
              <label class="form-label">URL</label>
              <input type="url" class="form-input" id="gameRegUrl" placeholder="https://example.com/game">
            </div>
            <div class="form-group">
              <label class="form-label">認証ID <span style="color:var(--hud-red);font-size:0.75rem;">※IDを知っている人のみ登録可</span></label>
              <div style="position:relative;">
                <input type="password" class="form-input" id="gameRegAuthId" placeholder="認証IDを入力" maxlength="30" style="padding-right:2.5rem;">
                <button type="button" onclick="toggleAuthIdVisibility()" id="authIdToggleBtn" style="position:absolute;right:0.5rem;top:50%;transform:translateY(-50%);background:none;border:none;color:var(--text-dim);cursor:pointer;font-size:1.1rem;padding:0.2rem;">👁️</button>
              </div>
            </div>
            <div class="error-message" id="gameRegError" style="margin-bottom:0.5rem;"></div>
            <button class="submit-btn" onclick="registerGame()" style="margin-bottom:0.8rem;">ゲームを追加</button>
            <div id="gameAuthStatus" style="font-size:0.75rem;margin-bottom:0.6rem;"></div>
            <div id="gameListAdmin"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="screen" id="entryScreen">
      <div class="hud-panel" style="max-width:480px;margin:2rem auto;">
        <div class="hud-panel-title">◆ エントリー登録</div>
        <div id="myEntryDisplay" style="display:none;">
          <div class="my-entry-box">
            <div class="my-entry-title">✓ エントリー済み</div>
            <div class="my-entry-info"><span id="myEntryName"></span><span class="my-entry-id" id="myEntryId"></span></div>
            <p style="font-size:0.75rem;color:var(--text-dim);margin-top:0.8rem;">※解除はタイトル画面の「登録解除」から</p>
          </div>
        </div>
        <div id="entryForm">
          <div class="form-group">
            <label class="form-label">ユーザーネーム</label>
            <input type="text" class="form-input" id="usernameInput" placeholder="ユーザーネームを入力" maxlength="20">
            <div class="error-message" id="usernameError"></div>
          </div>
          <div class="form-group">
            <label class="form-label">アイコン（任意）</label>
            <input type="file" accept="image/*" onchange="previewIcon(this)" style="display:none" id="iconInput">
            <div style="display:flex;align-items:center;gap:0.8rem;">
              <div style="position:relative;">
                <div id="iconPreview" style="width:55px;height:55px;border-radius:50%;border:2px solid var(--hud-green-dim);background:var(--bg-dark);display:flex;align-items:center;justify-content:center;overflow:hidden;cursor:pointer;" onclick="document.getElementById('iconInput').click()"><span style="color:var(--text-dim);font-size:1.3rem;">+</span></div>
                <button type="button" id="iconDeleteBtn" onclick="clearIcon()" style="display:none;position:absolute;top:-5px;right:-5px;width:20px;height:20px;border-radius:50%;background:var(--hud-red);border:none;color:white;font-size:0.8rem;cursor:pointer;line-height:1;">×</button>
              </div>
              <span style="color:var(--text-dim);font-size:0.8rem;">クリックして画像を選択</span>
            </div>
          </div>
          <button class="submit-btn" onclick="submitEntry()">エントリー登録</button>
        </div>
      </div>
    </div>
    <div class="screen" id="tournamentScreen">
      <div class="info-display" style="max-width:1200px;margin:1rem auto;">
        <div class="info-item"><div class="info-label">ゲーム名</div><div class="info-value" id="tournamentGameName">未設定</div></div>
        <div class="info-item"><div class="info-label">管理者</div><div class="info-value" id="tournamentAdmin">-</div></div>
        <div class="info-item"><div class="info-label">締切日時</div><div class="info-value" id="tournamentDeadline">未設定</div></div>
        <div class="info-item"><div class="info-label">参加者</div><div class="info-value" id="tournamentCount">0名</div></div>
      </div>
      
      <!-- 抽選会場へボタン -->
      <div id="lotteryEntrance" style="max-width:700px;margin:1rem auto;text-align:center;">
        <button class="lottery-venue-btn" id="lotteryVenueBtn" onclick="enterLotteryVenue()" disabled>
          <span class="lottery-icon">⚔️</span>
          <span class="lottery-text">抽選会場へ</span>
          <span class="lottery-sub" id="lotteryBtnSub">（締切後に解放）</span>
        </button>
      </div>

      <!-- 抽選会場（左：ルーレット、右：リスト） -->
      <div class="lottery-arena" id="lotteryArena">
        <!-- グループタブ（22人以上の場合表示） -->
        <div class="group-tabs-container" id="groupTabsContainer" style="display:none;grid-column:1/-1;">
          <div class="group-tabs" id="groupTabs"></div>
          <div class="group-info-text" id="groupInfoText"></div>
          <div id="groupBulkMatch" style="display:none;text-align:center;">
            <button class="bulk-match-btn" onclick="bulkMatchGroup()">⚡ 一括マッチメイク</button>
          </div>
        </div>
        <!-- 左側：ルーレット＋VS -->
        <div class="lottery-main">
          <div class="lottery-main-top">
            <div class="roulette-container" id="rouletteContainer">
            <div class="roulette-wheel">
              <div class="wheel-inner" id="wheelInner"></div>
              <!-- VS表示（中央に重ねる） -->
              <div class="vs-overlay">
                <div class="vs-display">
                  <div class="vs-title">⚔️ 対戦カード</div>
                  <div class="vs-players">
                    <div class="vs-player" id="vsPlayer1Box" onclick="selectWinnerFromCard(1)">
                      <div class="vs-player-icon" id="vsPlayer1Icon"><svg class="silhouette-icon" viewBox="0 0 100 120"><circle cx="50" cy="30" r="22"/><path d="M10 120 Q10 70 50 65 Q90 70 90 120Z"/></svg></div>
                      <div class="vs-player-id" id="vsPlayer1Id">-</div>
                      <div class="vs-player-name" id="vsPlayer1Name">-</div>
                    </div>
                    <div class="vs-text">VS</div>
                    <div class="vs-player" id="vsPlayer2Box" onclick="selectWinnerFromCard(2)">
                      <div class="vs-player-icon" id="vsPlayer2Icon"><svg class="silhouette-icon" viewBox="0 0 100 120"><circle cx="50" cy="30" r="22"/><path d="M10 120 Q10 70 50 65 Q90 70 90 120Z"/></svg></div>
                      <div class="vs-player-id" id="vsPlayer2Id">-</div>
                      <div class="vs-player-name" id="vsPlayer2Name">-</div>
                    </div>
                  </div>
                  <div class="vs-help" id="vsHelp" style="display:none;font-size:0.7rem;color:var(--hud-gold);margin-top:0.5rem;">※ 勝者をクリックしてください</div>
                </div>
              </div>
            </div>
          </div>
          <!-- ゲーム選択（ルーレット横の余白に配置） -->
          <div id="gameDropdownArea" class="game-select-area" style="display:none;">
            <div class="game-select-wrapper">
              <div class="game-select-header" onclick="toggleGameSelectPanel()">
                <span class="game-select-icon">🎮</span>
                <span class="game-select-label">ゲームを起動</span>
                <span class="game-select-arrow" id="gameSelectArrow">▼</span>
              </div>
              <div class="game-select-panel" id="gameSelectPanel" style="display:none;">
                <div class="game-select-list" id="gameSelectList"></div>
              </div>
            </div>
            <a id="gameHiddenLink" href="#" target="_blank" rel="noopener" style="display:none;"></a>
          </div>
          </div><!-- /lottery-main-top -->
          <!-- 操作ボタン -->
          <div class="roulette-controls" id="rouletteAdminControls" style="display:none;">
            <button class="roulette-btn" id="spinBtn" onclick="spinRoulette()">ルーレット回転</button>
            <button class="roulette-btn" id="endTournamentBtn" onclick="confirmEndTournament()" style="background:rgba(40,10,20,0.8);border-color:var(--hud-red);color:var(--hud-red);">大会終了・記録</button>
          </div>
          <!-- トーナメント表切り替えボタン（管理者用） -->
          <div class="roulette-controls" id="bracketControls" style="display:none;margin-top:1rem;">
            <button class="bracket-view-btn" id="showBracketBtn" onclick="toggleBracketView()">
              📊 トーナメント表を見る
            </button>
          </div>
        </div>
        
        <!-- トーナメント表（20名以下で表示可能） -->
        <div class="bracket-container" id="bracketContainer">
          <h3 class="bracket-title" id="bracketTitle">🏆 トーナメント表</h3>
          <div id="bracketContent"></div>
          <div style="margin-top:1rem;display:flex;gap:1rem;justify-content:center;flex-wrap:wrap;">
            <button class="bracket-view-btn" id="bracketBackBtn" onclick="toggleBracketView()">🎲 ルーレットに戻る</button>
            <button class="bracket-view-btn" id="bracketEndBtn" onclick="confirmEndTournament()" style="display:none;background:rgba(40,10,20,0.8);border-color:var(--hud-red);color:var(--hud-red);">🏆 大会終了・記録</button>
          </div>
        </div>
        
        <!-- 右側：参加者リスト -->
        <div class="lottery-sidebar">
          <!-- 現在のマッチ表示 -->
          <div class="current-match-display" id="currentMatchDisplay" style="display:none;">
            <div class="current-match-title">⚔️ 現在の対戦</div>
            <div class="current-match-vs">
              <span id="currentMatch1">-</span>
              <span>VS</span>
              <span id="currentMatch2">-</span>
            </div>
          </div>
          <div class="participant-panel">
            <div class="participant-header">
              <h3 class="participant-title">◆ 参加者リスト</h3>
              <input type="text" class="participant-search" placeholder="🔍 検索" oninput="filterParticipants(this.value)">
            </div>
            <div class="participant-row header"><div>ID</div><div>Icon</div><div>ユーザー名</div><div>状態</div></div>
            <div class="participant-list" id="participantList"></div>
            <div class="participant-count">参加者数: <span id="listCount">0</span>/100</div>
          </div>
        </div>
      </div>
      
      <!-- 抽選会場入場前の参加者リスト -->
      <div class="participant-panel" id="preArenaList" style="max-width:700px;margin:1rem auto;">
        <div class="participant-header">
          <h3 class="participant-title">◆ 参加者リスト</h3>
          <input type="text" class="participant-search" placeholder="🔍 検索" oninput="filterParticipants(this.value)">
        </div>
        <div class="participant-row header"><div>ID</div><div>Icon</div><div>ユーザー名</div><div>状態</div></div>
        <div class="participant-list" id="participantListPre"></div>
        <div class="participant-count">参加者数: <span id="listCountPre">0</span>/100（最大100人）</div>
      </div>
    </div>
    <div class="screen" id="historyScreen">
      <div class="hud-panel" style="max-width:600px;margin:2rem auto;">
        <div class="hud-panel-title">◆ 過去の大会記録</div>
        <div id="historyList"></div>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="userGuideModal">
    <div class="modal-content guide-modal">
      <button class="modal-close-btn" onclick="hideModal('userGuideModal')">×</button>
      <h3 class="modal-title">◆ 使い方ガイド</h3>
      <div class="guide-content">
        <h4>🎮 トーナメントアプリとは</h4><p>参加者同士をマッチングさせ、勝ち残った人が優勝する大会形式を作成・運営できるアプリです。</p>
        <h4>📝 エントリー方法</h4><ul><li>管理者が締切日時を設定すると「エントリー登録する」が有効になります</li><li>ユーザーネームを入力して登録してください</li><li>締切日時までなら「登録解除」で解除可能です</li></ul>
        <h4>⚔️ 抽選会場</h4><ul><li>締切時間が過ぎると「抽選会場へ」ボタンが解放されます</li><li>ボタンをクリックして抽選会場へ移動してください</li><li>管理者がルーレットで対戦カードを決定します</li></ul>
        <h4>🎮 ゲーム選択</h4><ul><li>抽選会場にゲーム選択のドロップダウンが表示されます</li><li>ゲーム名を選択すると、対応するゲーム画面へ移動できます</li></ul>
        <h4>👀 トーナメントを見る</h4><p>大会情報や参加者リストを確認できます。</p>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="adminGuideModal">
    <div class="modal-content guide-modal">
      <button class="modal-close-btn" onclick="hideModal('adminGuideModal')">×</button>
      <h3 class="modal-title" style="color:var(--hud-gold);">◆ 管理者ガイド</h3>
      <div class="guide-content">
        <h4>🔐 管理者登録</h4><p>「管理者登録をする」から管理者名を入力して登録します。</p>
        <h4>⚙️ 大会設定</h4><ul><li>ゲーム名（大会名）を入力</li><li>エントリー締切日時を設定</li><li>設定保存でエントリー登録が有効化されます</li></ul>
        <h4>🎮 ゲーム登録</h4><ul><li>大会設定画面の「ゲーム登録」セクションからゲーム名とURLを登録できます</li><li>登録したゲームは抽選会場のドロップダウンに表示されます</li><li>プレイヤーがゲーム名を選択するとURLへ移動します</li><li>いつでもゲームの追加・削除が可能です</li><li>登録上限: <strong>20件</strong>まで</li></ul>
        <h4>📋 操作ルール</h4><ul><li>各操作には回数制限があります</li><li>短時間に連続で同じ操作を行った場合、一定時間お待ちいただくことがあります</li></ul>
        <h4>🎲 対戦カード抽選</h4><ul><li>締切日時が過ぎると「抽選会場へ」が解放されます</li><li>プレイヤーに抽選会場へ移動するよう案内してください</li><li>ルーレットで対戦カードを決定します</li></ul>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="confirmCancelEntryModal">
    <div class="modal-content">
      <button class="modal-close-btn" onclick="hideModal('confirmCancelEntryModal')">×</button>
      <h3 class="modal-title">◆ エントリー解除</h3>
      <p style="text-align:center;margin:0.8rem 0;">エントリーを解除しますか？</p>
      <p style="text-align:center;color:var(--text-dim);font-size:0.85rem;">参加者リストから削除されます。</p>
      <div class="modal-buttons">
        <button class="modal-btn modal-btn-cancel" onclick="hideModal('confirmCancelEntryModal')">キャンセル</button>
        <button class="modal-btn modal-btn-confirm" style="background:var(--hud-red);" onclick="executeCancelEntry()">解除する</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="cancelCompleteModal">
    <div class="modal-content">
      <h3 class="modal-title">✅ 解除完了</h3>
      <p style="text-align:center;margin:0.8rem 0;">エントリーを解除しました。</p>
      <div class="modal-buttons"><button class="modal-btn modal-btn-confirm" onclick="hideModal('cancelCompleteModal')">OK</button></div>
    </div>
  </div>
  <div class="modal-overlay" id="settingsCompleteModal">
    <div class="modal-content">
      <h3 class="modal-title">✅ 設定完了</h3>
      <p style="text-align:center;margin:0.8rem 0;">大会設定が保存されました。</p>
      <p style="text-align:center;color:var(--text-dim);font-size:0.85rem;">締切日時まで、参加者のエントリーを待ちましょう。</p>
      <div class="modal-buttons"><button class="modal-btn modal-btn-confirm" onclick="hideModal('settingsCompleteModal');navigateTo('tournamentScreen',true)">確認する</button></div>
    </div>
  </div>
  <div class="modal-overlay" id="entryCompleteModal">
    <div class="modal-content">
      <h3 class="modal-title">🎉 エントリー完了</h3>
      <p style="text-align:center;margin:0.8rem 0;">エントリーが完了しました！</p>
      <p style="text-align:center;color:var(--hud-gold);font-size:1rem;" id="entryCompleteInfo"></p>
      <div class="modal-buttons"><button class="modal-btn modal-btn-confirm" onclick="hideModal('entryCompleteModal');navigateTo('tournamentScreen',true)">確認する</button></div>
    </div>
  </div>
  <!-- シード抽選確認モーダル -->
  <div class="modal-overlay" id="seedLotteryModal">
    <div class="modal-content">
      <button class="modal-close-btn" onclick="hideModal('seedLotteryModal')">×</button>
      <h3 class="modal-title" style="color:var(--hud-gold);">🎖️ シード抽選</h3>
      <p style="text-align:center;margin:0.8rem 0;color:var(--text-dim);" id="seedLotteryInfo"></p>
      <p style="text-align:center;margin:0.5rem 0;color:var(--hud-green);font-size:0.9rem;">シード権を獲得した選手は次のラウンドに自動進出します</p>
      <div class="modal-buttons">
        <button class="modal-btn modal-btn-cancel" onclick="hideModal('seedLotteryModal')">キャンセル</button>
        <button class="modal-btn modal-btn-confirm" onclick="executeSeedLottery()" style="background:var(--hud-gold);border-color:var(--hud-gold);color:#000;">シード抽選を開始</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="confirmWinnerModal">
    <div class="modal-content">
      <button class="modal-close-btn" onclick="hideModal('confirmWinnerModal')">×</button>
      <h3 class="modal-title">勝者を確定しますか？</h3>
      <p style="text-align:center;margin:0.8rem 0;color:var(--hud-gold);font-size:1.2rem;" id="confirmWinnerText"></p>
      <div class="modal-buttons">
        <button class="modal-btn modal-btn-cancel" onclick="hideModal('confirmWinnerModal')">キャンセル</button>
        <button class="modal-btn modal-btn-confirm" onclick="executeWinner()">確定</button>
      </div>
    </div>
  </div>
  <!-- 大会終了確認モーダル -->
  <div class="modal-overlay" id="endTournamentModal">
    <div class="modal-content">
      <button class="modal-close-btn" onclick="hideModal('endTournamentModal')">×</button>
      <h3 class="modal-title" style="color:var(--hud-red);">大会を終了しますか？</h3>
      <p id="endTournamentDesc" style="text-align:center;color:var(--text-dim);margin:0.8rem 0;font-size:0.9rem;">優勝者を選択して記録を保存します</p>
      <div class="form-group" id="championSelectGroup">
        <label class="form-label" id="championSelectLabel">優勝者を選択</label>
        <select id="championSelect" class="form-input" style="width:100%;padding:0.8rem;">
          <option value="">-- 選択してください --</option>
        </select>
      </div>
      <div class="modal-buttons">
        <button class="modal-btn modal-btn-cancel" onclick="hideModal('endTournamentModal')">キャンセル</button>
        <button class="modal-btn modal-btn-confirm" onclick="executeEndTournament()" style="background:var(--hud-red);border-color:var(--hud-red);">大会終了・記録</button>
      </div>
    </div>
  </div>
  <!-- リセット確認モーダル -->
  <div class="modal-overlay" id="resetTournamentModal">
    <div class="modal-content">
      <button class="modal-close-btn" onclick="hideModal('resetTournamentModal')">×</button>
      <h3 class="modal-title" style="color:var(--hud-red);">⚠️ 大会をリセットしますか？</h3>
      <p style="text-align:center;color:var(--text-dim);margin:0.8rem 0;font-size:0.9rem;">管理者登録が解除され、大会設定・エントリー情報が全て削除されます。この操作は取り消せません。</p>
      <div class="modal-buttons">
        <button class="modal-btn modal-btn-cancel" onclick="hideModal('resetTournamentModal')">キャンセル</button>
        <button class="modal-btn modal-btn-confirm" onclick="executeResetTournament()" style="background:var(--hud-red);border-color:var(--hud-red);">リセット実行</button>
      </div>
    </div>
  </div>
  <div class="toast" id="toast"></div>
  
  <!-- BGM/SE Controls -->
  <div class="sound-controls" id="soundControls">
    <button class="sound-btn" id="bgmBtn" onclick="toggleBGM()" title="BGM ON/OFF">🎵</button>
    <button class="sound-btn" id="seBtn" onclick="toggleSE()" title="SE ON/OFF">🔊</button>
  </div>
  
  <!-- HUD - リアルタイム情報パネル（PC専用） -->
  <div class="hud-info-panel" id="hudPanel">
    <div class="hud-content">
      <!-- 状態バー（上部横長） -->
      <div class="hud-status-bar">
        <div class="hud-status-left">
          <span class="hud-status-title">▶ ステータス</span>
          <div class="hud-status-list">
            <span class="hud-status-item active" id="statusReception">受付中</span>
            <span class="hud-status-item" id="statusClosed">受付終了</span>
            <span class="hud-status-item" id="statusProgress">進行中</span>
            <span class="hud-status-item" id="statusEnd">終了</span>
          </div>
        </div>
        <div class="hud-next-event" id="hudNextEvent"></div>
        <div class="hud-system-notice" id="hudSystemNotice"></div>
      </div>
      <!-- 行動ログ（下部） -->
      <div class="hud-log-area">
        <div class="hud-log-title">▶ リアルタイムログ</div>
        <div class="hud-log-list" id="hudLogList"></div>
      </div>
    </div>
  </div>
  
  <!-- BGM Audio -->
  <audio id="bgmAudio" loop preload="auto">
    <source src="./tournament.mp3" type="audio/mpeg">
  </audio>
  <audio id="battleBgmAudio" loop preload="auto">
    <source src="./Battle Match.mp3" type="audio/mpeg">
  </audio>
  <audio id="vsSoundAudio" preload="auto">
    <source src="./VS用.mp3" type="audio/mpeg">
  </audio>
  
  <div class="calendar-modal" id="calendarModal">
    <div class="calendar-container">
      <button class="calendar-close" onclick="closeCalendar()">×</button>
      <h3 class="calendar-title">締切日時を選択</h3>
      <div class="calendar-header">
        <button class="calendar-nav" onclick="changeMonth(-1)">◀</button>
        <span class="calendar-month-year" id="calendarMonthYear"></span>
        <button class="calendar-nav" onclick="changeMonth(1)">▶</button>
      </div>
      <div class="calendar-weekdays"><div class="calendar-weekday">日</div><div class="calendar-weekday">月</div><div class="calendar-weekday">火</div><div class="calendar-weekday">水</div><div class="calendar-weekday">木</div><div class="calendar-weekday">金</div><div class="calendar-weekday">土</div></div>
      <div class="calendar-days" id="calendarDays"></div>
      <div class="calendar-time">
        <input type="number" class="calendar-time-input" id="calendarHour" min="0" max="23" value="12">
        <span style="color:var(--text-dim);">:</span>
        <input type="number" class="calendar-time-input" id="calendarMinute" min="0" max="59" value="00" step="5">
      </div>
      <div class="calendar-selected-display" id="calendarSelectedDisplay">日付を選択してください</div>
      <button class="calendar-confirm" onclick="confirmCalendar()">この日時で設定</button>
    </div>
  </div>
  <script>
    const appState = {
      deviceId: localStorage.getItem('tournament_device_id') || (() => { const id = 'dev_' + Math.random().toString(36).substr(2,9) + Date.now().toString(36); localStorage.setItem('tournament_device_id', id); return id; })(),
      isAdmin: false,
      adminName: localStorage.getItem('tournament_admin_name') || null,
      tournament: null,
      entries: [],
      matches: [],
      games: [],
      gameAuthHash: null,
      selectedPlayer1: null,
      selectedPlayer2: null,
      isSpinning: false,
      pendingWinner: null,
      matchingIds: [],
      activeGroup: null,
      groupPhase: null
    };
    if (appState.adminName) appState.isAdmin = true;

    // BGM/SE State
    let bgmEnabled = true;
    let seEnabled = true;
    let bgmVolume = 0.3;
    let seVolume = 0.5;
    let currentBgm = 'normal'; // 'normal' or 'battle'
    const bgmAudio = document.getElementById('bgmAudio');
    const battleBgmAudio = document.getElementById('battleBgmAudio');
    const vsSoundAudio = document.getElementById('vsSoundAudio');

    function toggleBGM() {
      bgmEnabled = !bgmEnabled;
      const btn = document.getElementById('bgmBtn');
      if (bgmEnabled) {
        btn.classList.remove('off');
        btn.textContent = '🎵';
        if (currentBgm === 'normal') {
          bgmAudio.play().catch(e => {});
        } else {
          battleBgmAudio.play().catch(e => {});
        }
      } else {
        btn.classList.add('off');
        btn.textContent = '🔇';
        bgmAudio.pause();
        battleBgmAudio.pause();
      }
    }

    function setBGMVolume(val) {
      bgmVolume = val / 100;
      bgmAudio.volume = bgmVolume;
      battleBgmAudio.volume = bgmVolume;
    }

    function toggleSE() {
      seEnabled = !seEnabled;
      const btn = document.getElementById('seBtn');
      if (seEnabled) {
        btn.classList.remove('off');
        btn.textContent = '🔊';
      } else {
        btn.classList.add('off');
        btn.textContent = '🔇';
      }
    }

    function setSEVolume(val) {
      seVolume = val / 100;
      vsSoundAudio.volume = seVolume;
    }

    // BGMをバトル用に切り替え
    function switchToBattleBGM() {
      console.log('switchToBattleBGM called, currentBgm:', currentBgm, 'bgmEnabled:', bgmEnabled);
      currentBgm = 'battle';
      bgmAudio.pause();
      bgmAudio.currentTime = 0;
      battleBgmAudio.volume = bgmVolume;
      if (bgmEnabled) {
        battleBgmAudio.play().then(() => {
          console.log('Battle BGM playing');
        }).catch(e => {
          console.log('Battle BGM error:', e);
          // フォールバック：少し待ってから再試行
          setTimeout(() => {
            battleBgmAudio.play().catch(e2 => console.log('Battle BGM retry failed:', e2));
          }, 100);
        });
      }
    }

    // BGMを通常に戻す
    function switchToNormalBGM() {
      if (currentBgm === 'normal') return;
      currentBgm = 'normal';
      battleBgmAudio.pause();
      battleBgmAudio.currentTime = 0;
      bgmAudio.volume = bgmVolume;
      if (bgmEnabled) {
        bgmAudio.play().catch(e => console.log('Normal BGM blocked'));
      }
    }

    // VS効果音を再生
    function playVsSound() {
      if (!seEnabled) return;
      vsSoundAudio.volume = seVolume;
      vsSoundAudio.currentTime = 0;
      vsSoundAudio.play().catch(e => console.log('VS sound blocked'));
    }
    
    // BGM用のAudioContext（フォールバック用）
    let bgmContext = null;
    let bgmOscillators = [];
    let bgmGains = [];
    let bgmPlaying = false;
    
    // BGMフォールバック（mp3がない場合）
    function startBgmFallback(isBattle = false) {
      if (!bgmEnabled) return;
      stopBgmFallback();
      
      try {
        bgmContext = new (window.AudioContext || window.webkitAudioContext)();
        bgmPlaying = true;
        
        // シンプルなアンビエントBGM
        const baseFreq = isBattle ? 110 : 65;
        const notes = isBattle ? [110, 138, 165, 138] : [65, 82, 98, 82];
        let noteIndex = 0;
        
        function playNote() {
          if (!bgmPlaying || !bgmContext) return;
          
          const osc = bgmContext.createOscillator();
          const gain = bgmContext.createGain();
          osc.connect(gain);
          gain.connect(bgmContext.destination);
          
          osc.type = isBattle ? 'sawtooth' : 'sine';
          osc.frequency.setValueAtTime(notes[noteIndex], bgmContext.currentTime);
          gain.gain.setValueAtTime(bgmVolume * 0.15, bgmContext.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, bgmContext.currentTime + 0.8);
          
          osc.start(bgmContext.currentTime);
          osc.stop(bgmContext.currentTime + 0.9);
          
          noteIndex = (noteIndex + 1) % notes.length;
          
          if (bgmPlaying) {
            setTimeout(playNote, 900);
          }
        }
        
        playNote();
      } catch(e) {
        console.log('BGM fallback error:', e);
      }
    }
    
    function stopBgmFallback() {
      bgmPlaying = false;
      if (bgmContext) {
        try {
          bgmContext.close();
        } catch(e) {}
        bgmContext = null;
      }
    }
    
    // VS効果音のフォールバック（WebAudioAPI）
    function playVsSoundFallback() {
      if (!seEnabled) return;
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        
        // ドラマチックな「VS」効果音を生成
        const duration = 0.8;
        
        // 低音のインパクト
        const osc1 = ctx.createOscillator();
        const gain1 = ctx.createGain();
        osc1.connect(gain1);
        gain1.connect(ctx.destination);
        osc1.type = 'sine';
        osc1.frequency.setValueAtTime(80, ctx.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + duration);
        gain1.gain.setValueAtTime(seVolume * 0.6, ctx.currentTime);
        gain1.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
        osc1.start(ctx.currentTime);
        osc1.stop(ctx.currentTime + duration);
        
        // 高音のアクセント
        const osc2 = ctx.createOscillator();
        const gain2 = ctx.createGain();
        osc2.connect(gain2);
        gain2.connect(ctx.destination);
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(800, ctx.currentTime);
        osc2.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.3);
        gain2.gain.setValueAtTime(seVolume * 0.3, ctx.currentTime);
        gain2.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
        osc2.start(ctx.currentTime);
        osc2.stop(ctx.currentTime + 0.3);
        
      } catch(e) { console.log('VS fallback error:', e); }
    }

    // BGMのフォールバック（Web Audio APIでアンビエント音を生成）
    // 注: startBgmFallback関数を使用

    function initBGM() {
      bgmAudio.volume = bgmVolume;
      battleBgmAudio.volume = bgmVolume;
      vsSoundAudio.volume = seVolume;
      document.addEventListener('click', () => {
        if (bgmEnabled && bgmAudio.paused && currentBgm === 'normal') {
          bgmAudio.play().catch(e => {});
        }
      }, { once: true });
    }

    function playClick() { if (!seEnabled) return; try { const c=new(window.AudioContext||window.webkitAudioContext)(),o=c.createOscillator(),g=c.createGain();o.connect(g);g.connect(c.destination);o.frequency.value=800;o.type='sine';g.gain.setValueAtTime(seVolume*0.5,c.currentTime);g.gain.exponentialRampToValueAtTime(0.01,c.currentTime+0.1);o.start(c.currentTime);o.stop(c.currentTime+0.1);} catch(e){} }
    function playHover() { if (!seEnabled) return; try { const c=new(window.AudioContext||window.webkitAudioContext)(),o=c.createOscillator(),g=c.createGain();o.connect(g);g.connect(c.destination);o.frequency.value=600;o.type='sine';g.gain.setValueAtTime(seVolume*0.12,c.currentTime);g.gain.exponentialRampToValueAtTime(0.01,c.currentTime+0.04);o.start(c.currentTime);o.stop(c.currentTime+0.04);} catch(e){} }
    function addSounds() { document.querySelectorAll('button').forEach(b => { b.addEventListener('mouseenter', () => { if(!b.disabled) playHover(); }); b.addEventListener('click', () => { if(!b.disabled) playClick(); }); }); }

    // HUD - リアルタイムログ管理
    const hudLogs = [];
    const MAX_LOGS = 10;

    function appendLog(message) {
      const now = new Date();
      const timeStr = now.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      
      // ローカル配列に追加（滝型：新しいログが上）
      hudLogs.unshift({ time: timeStr, message: message });
      
      // 上限超過時は最下段から削除
      if (hudLogs.length > MAX_LOGS) {
        hudLogs.pop();
      }
      
      renderLogs();
      
      // Firebaseにログを保存（他ユーザーと共有）
      if (db) {
        db.collection('logs').add({
          time: timeStr,
          message: message,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        }).then(() => {
          // 古いログを削除（10件を超えたら）
          cleanupOldLogs();
        }).catch(e => console.error('Log save error:', e));
      }
    }

    // 古いログを削除（MAX_LOGS件を超えた分）
    function cleanupOldLogs() {
      if (!db) return;
      
      db.collection('logs')
        .orderBy('timestamp', 'desc')
        .get()
        .then(snapshot => {
          if (snapshot.size > MAX_LOGS) {
            const batch = db.batch();
            let count = 0;
            snapshot.forEach(doc => {
              count++;
              // MAX_LOGS件より古いものを削除
              if (count > MAX_LOGS) {
                batch.delete(doc.ref);
              }
            });
            batch.commit().catch(e => console.error('Log cleanup error:', e));
          }
        })
        .catch(e => console.error('Log count error:', e));
    }

    // Firebaseからログをリアルタイム取得
    function initLogListener() {
      if (!db) return;
      
      db.collection('logs')
        .orderBy('timestamp', 'desc')
        .limit(MAX_LOGS)
        .onSnapshot(snapshot => {
          // 他デバイスからのログを反映
          const firebaseLogs = [];
          snapshot.forEach(doc => {
            const data = doc.data();
            if (data.time && data.message) {
              firebaseLogs.push({ time: data.time, message: data.message });
            }
          });
          
          // ローカルログをFirebaseログで更新
          hudLogs.length = 0;
          firebaseLogs.forEach(log => hudLogs.push(log));
          
          renderLogs();
        }, err => console.error('Log listener error:', err));
    }

    function renderLogs() {
      const logList = document.getElementById('hudLogList');
      const logListMobile = document.getElementById('hudLogListMobile');
      
      const html = hudLogs.map((log, index) => {
        const fadeClass = index === 0 ? 'fade-in' : '';
        return '<div class="hud-log-item ' + fadeClass + '"><span class="log-time">' + log.time + '</span>' + escapeHtml(log.message) + '</div>';
      }).join('');
      
      if (logList) logList.innerHTML = html;
      if (logListMobile) logListMobile.innerHTML = html;
    }

    // トーナメント状態の更新
    function updateTournamentStatus(status) {
      const statuses = ['statusReception', 'statusClosed', 'statusProgress', 'statusEnd'];
      const statusesMobile = ['statusReceptionMobile', 'statusClosedMobile', 'statusProgressMobile', 'statusEndMobile'];
      
      statuses.forEach(id => {
        document.getElementById(id)?.classList.remove('active');
      });
      statusesMobile.forEach(id => {
        document.getElementById(id)?.classList.remove('active');
      });
      
      const statusMap = {
        'reception': 'statusReception',
        'closed': 'statusClosed',
        'progress': 'statusProgress',
        'end': 'statusEnd'
      };
      const statusMapMobile = {
        'reception': 'statusReceptionMobile',
        'closed': 'statusClosedMobile',
        'progress': 'statusProgressMobile',
        'end': 'statusEndMobile'
      };
      
      if (statusMap[status]) {
        document.getElementById(statusMap[status])?.classList.add('active');
        document.getElementById(statusMapMobile[status])?.classList.add('active');
      }
    }

    // 次のイベント予告の更新
    function updateNextEvent(message) {
      const el = document.getElementById('hudNextEvent');
      const elMobile = document.getElementById('hudNextEventMobile');
      if (el) el.textContent = message || '';
      if (elMobile) elMobile.textContent = message || '';
    }

    // システム通知の更新
    function updateSystemNotice(message) {
      const el = document.getElementById('hudSystemNotice');
      if (el) el.textContent = message || '';
    }

    // 状態判定と更新
    function checkAndUpdateStatus() {
      const t = appState.tournament;
      const dl = t?.deadline;
      
      if (!dl) {
        updateTournamentStatus('none'); // 未設定時は何も発光させない
        updateNextEvent('管理者の設定を待っています');
        updateLotteryVenueButton();
        return;
      }
      
      const deadline = dl.toDate ? dl.toDate() : new Date(dl);
      const now = new Date();
      
      if (now < deadline) {
        updateTournamentStatus('reception');
        const diff = deadline - now;
        const hours = Math.floor(diff / (1000 * 60 * 60));
        const mins = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const secs = Math.floor((diff % (1000 * 60)) / 1000);
        
        // 1時間以内は秒数も表示
        if (hours === 0 && mins < 60) {
          if (mins === 0) {
            updateNextEvent('締切まで: ' + secs + '秒');
          } else {
            updateNextEvent('締切まで: ' + mins + '分 ' + secs + '秒');
          }
        } else {
          updateNextEvent('締切まで: ' + hours + '時間 ' + mins + '分');
        }
      } else {
        // 締切後
        const activeCount = appState.entries.filter(e => e.status !== 'LOST').length;
        if (activeCount > 1) {
          updateTournamentStatus('progress');
          updateNextEvent('管理者の操作を待っています');
        } else if (activeCount === 1) {
          updateTournamentStatus('end');
          updateNextEvent('');
        } else {
          updateTournamentStatus('closed');
          updateNextEvent('');
        }
      }
      
      // ボタン状態も更新
      updateLotteryVenueButton();
      updateEntryButton();
      updateCancelEntryButton();
      updateMatchmakingButton();
    }
    
    // 定期的にステータスをチェック（1秒ごと）
    setInterval(() => {
      checkAndUpdateStatus();
    }, 1000);

    function createMatrixBg() {
      const bg = document.getElementById('matrixBg');
      const chars = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン0123456789ABCDEF';
      for (let i = 0; i < 35; i++) {
        const col = document.createElement('div');
        col.className = 'matrix-col';
        col.style.left = (i * 2.9 + Math.random()) + '%';
        col.style.animationDuration = (8 + Math.random() * 12) + 's';
        col.style.animationDelay = (Math.random() * -15) + 's';
        let text = '';
        for (let j = 0; j < 45; j++) text += chars[Math.floor(Math.random() * chars.length)] + '\n';
        col.textContent = text;
        bg.appendChild(col);
      }
    }
    createMatrixBg();

    let currentScreen = 'titleScreen';
    let screenHistory = [];

    function navigateTo(screenId, directToTitle = false) {
      if (screenId === 'entryScreen') { if (!appState.tournament?.deadline) { showToast('締切日時が設定されていません', 'error'); return; } updateEntryScreen(); }
      if (screenId === 'historyScreen') loadHistory();
      if (screenId === 'tournamentScreen') { initTournamentScreen(); }
      screenHistory.push(currentScreen);
      document.getElementById(currentScreen).classList.remove('active');
      document.getElementById(screenId).classList.add('active');
      currentScreen = screenId;
      const header = document.getElementById('mainHeader');
      const backBtn = document.getElementById('backBtn');
      if (screenId === 'titleScreen') { header.classList.remove('visible'); } else { header.classList.add('visible'); }
      if (directToTitle) { backBtn.textContent = '◀ タイトルに戻る'; backBtn.onclick = goToTitle; } else { backBtn.textContent = '◀ 戻る'; backBtn.onclick = goBack; }
      backBtn.classList.toggle('visible', screenId !== 'titleScreen');
      updateHudVisibility();
    }
    
    // トーナメント画面の初期化（大会がない場合のみリセット）
    function initTournamentScreen() {
      // 大会が存在する場合はリセットしない
      if (appState.tournament) {
        // ボタン状態だけ更新
        updateLotteryVenueButton();
        return;
      }
      
      // 大会がない場合のみ、抽選会場関連を初期状態に戻す
      const lotteryArena = document.getElementById('lotteryArena');
      const lotteryEntrance = document.getElementById('lotteryEntrance');
      const preArenaList = document.getElementById('preArenaList');
      const bracketContainer = document.getElementById('bracketContainer');
      const rouletteMain = document.querySelector('.lottery-main');
      const lotterySidebar = document.querySelector('.lottery-sidebar');
      const rouletteAdminControls = document.getElementById('rouletteAdminControls');
      const bracketControls = document.getElementById('bracketControls');
      
      // 抽選会場を非表示、入口ボタンを表示
      if (lotteryArena) {
        lotteryArena.classList.remove('active');
        lotteryArena.style.display = '';
        lotteryArena.style.gridTemplateColumns = '';
      }
      if (lotteryEntrance) lotteryEntrance.style.display = '';
      if (preArenaList) preArenaList.style.display = '';
      if (bracketContainer) bracketContainer.classList.remove('active');
      if (rouletteMain) rouletteMain.style.display = 'flex';
      if (lotterySidebar) lotterySidebar.style.display = '';
      if (rouletteAdminControls) rouletteAdminControls.style.display = 'none';
      if (bracketControls) bracketControls.style.display = 'none';
      
      // bracketModeをリセット
      bracketMode = false;
      
      // VS表示をリセット（関数が存在する場合のみ）
      if (typeof updateVsDisplay === 'function') updateVsDisplay(null, null);
      if (typeof disableWinnerSelection === 'function') disableWinnerSelection();
      
      // ボタン状態を更新
      updateLotteryVenueButton();
    }
    function goBack() { if (screenHistory.length > 0) { const prev = screenHistory.pop(); document.getElementById(currentScreen).classList.remove('active'); document.getElementById(prev).classList.add('active'); currentScreen = prev; const header = document.getElementById('mainHeader'); if (currentScreen === 'titleScreen') header.classList.remove('visible'); else header.classList.add('visible'); document.getElementById('backBtn').classList.toggle('visible', currentScreen !== 'titleScreen'); updateHudVisibility(); } }
    function goToTitle() { document.getElementById(currentScreen).classList.remove('active'); document.getElementById('titleScreen').classList.add('active'); currentScreen = 'titleScreen'; screenHistory = []; document.getElementById('mainHeader').classList.remove('visible'); updateHudVisibility(); }
    function updateHudVisibility() { const hud = document.getElementById('hudPanel'); if (hud) { if (currentScreen === 'titleScreen' && window.innerWidth >= 900) { hud.classList.add('title-active'); } else { hud.classList.remove('title-active'); } } }
    function showModal(id) { document.getElementById(id).classList.add('active'); }
    function hideModal(id) { document.getElementById(id).classList.remove('active'); }
    function showToast(msg, type = 'success') { const t = document.getElementById('toast'); t.textContent = msg; t.className = 'toast ' + type + ' visible'; setTimeout(() => t.classList.remove('visible'), 3000); }
    function showGuide(type) { showModal(type === 'admin' ? 'adminGuideModal' : 'userGuideModal'); }
    function showMatchmakingInfo() {
      const dl = appState.tournament?.deadline;
      if (dl) {
        const d = dl.toDate ? dl.toDate() : new Date(dl);
        if (new Date() >= d) {
          switchToBattleBGM();
          navigateTo('tournamentScreen');
          document.getElementById('lotteryEntrance').style.display = 'none';
          document.getElementById('preArenaList').style.display = 'none';
          const lotteryArena = document.getElementById('lotteryArena');
          lotteryArena.style.display = '';
          lotteryArena.classList.add('active');
          document.getElementById('rouletteAdminControls').style.display = 'flex';

          // ゲームドロップダウン表示
          showGameDropdown();

          // 22人以上でグループ未割り当てなら自動グループ分け
          if (appState.entries.length >= 22 && !appState.tournament?.groups_assigned) {
            assignGroups();
          }
          if (appState.tournament?.group_phase) {
            appState.activeGroup = appState.tournament.active_group || 'A';
            appState.groupPhase = appState.tournament.group_phase;
            renderGroupTabs();
          }

          updateBracketControls();
          return;
        }
      }
      showToast('締切日時以降に有効化されます', 'error');
    }
    function previewIcon(input) { if (input.files && input.files[0]) { const r = new FileReader(); r.onload = e => { document.getElementById('iconPreview').innerHTML = '<img src="' + e.target.result + '" style="width:100%;height:100%;object-fit:cover;">'; document.getElementById('iconDeleteBtn').style.display = 'block'; }; r.readAsDataURL(input.files[0]); } }
    function clearIcon() { document.getElementById('iconPreview').innerHTML = '<span style="color:var(--text-dim);font-size:1.3rem;">+</span>'; document.getElementById('iconInput').value = ''; document.getElementById('iconDeleteBtn').style.display = 'none'; }
    function escapeHtml(s) { return s ? s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;') : ''; }

    function updateTournamentDisplay() {
      const t = appState.tournament;
      const gn = t?.game_name || '未設定';
      const ad = t?.admin_name || '-';
      let dl = '未設定';
      if (t?.deadline) { const d = t.deadline.toDate ? t.deadline.toDate() : new Date(t.deadline); dl = d.toLocaleString('ja-JP', {year:'numeric',month:'numeric',day:'numeric',hour:'2-digit',minute:'2-digit'}); }
      document.getElementById('titleGameName').textContent = gn;
      document.getElementById('titleDeadline').textContent = dl;
      document.getElementById('titleDeadline').classList.toggle('warning', dl === '未設定');
      document.getElementById('titleAdmin').textContent = ad;
      document.getElementById('titleCount').textContent = appState.entries.length + '名';
      document.getElementById('tournamentGameName').textContent = gn;
      document.getElementById('tournamentDeadline').textContent = dl;
      document.getElementById('tournamentDeadline').classList.toggle('warning', dl === '未設定');
      document.getElementById('tournamentAdmin').textContent = ad;
      document.getElementById('tournamentCount').textContent = appState.entries.length + '名';
      const participantCountEl = document.getElementById('titleParticipantCount');
      if (participantCountEl) participantCountEl.textContent = appState.entries.length;
      updateEntryButton();
      updateCancelEntryButton();
      updateMatchmakingButton();
      updateLotteryVenueButton();
      updateAdminRegisterButton();
      updateTournamentViewButton();
      checkAndUpdateStatus();
    }
    function updateAdminRegisterButton() {
      const btn = document.getElementById('adminRegisterBtn');
      if (!btn) return;
      // 既に管理者が登録されている場合は他ユーザーは押せない
      if (appState.tournament?.admin_device && appState.tournament.admin_device !== appState.deviceId) {
        btn.disabled = true;
        btn.style.opacity = '0.3';
        btn.style.cursor = 'not-allowed';
      } else {
        btn.disabled = false;
        btn.style.opacity = '';
        btn.style.cursor = '';
      }
    }
    
    // 管理者画面へのアクセス制御
    function goToAdminScreen() {
      // 大会が設定されていない場合 → 管理者登録画面へ
      if (!appState.tournament?.admin_device) {
        navigateTo('adminScreen');
        return;
      }
      
      // 大会が設定されている場合 → 登録した管理者のデバイスのみ
      if (appState.tournament.admin_device === appState.deviceId) {
        navigateTo('adminSetupScreen');
        return;
      }
      
      // それ以外 → エラー
      showToast('管理者以外はアクセスできません', 'error');
    }
    
    function updateEntryButton() { const b = document.getElementById('entryBtn'); if (!appState.tournament?.deadline) { b.disabled = true; } else { const d = appState.tournament.deadline.toDate ? appState.tournament.deadline.toDate() : new Date(appState.tournament.deadline); b.disabled = new Date() > d; } }
    function updateCancelEntryButton() { const b = document.getElementById('cancelEntryBtn'); if (!b) return; const my = appState.entries.find(e => e.device_id === appState.deviceId); let can = !!my; const dl = appState.tournament?.deadline; if (dl) { const d = dl.toDate ? dl.toDate() : new Date(dl); if (new Date() >= d) can = false; } b.disabled = !can; }
    function updateMatchmakingButton() { const b = document.getElementById('matchmakingBtn'); if (!b) return; const dl = appState.tournament?.deadline; if (!dl) { b.style.opacity = '0.5'; b.textContent = '🎲 対戦カード抽選（締切後に有効化）'; b.classList.remove('matchmaking-active'); return; } const d = dl.toDate ? dl.toDate() : new Date(dl); if (new Date() >= d) { b.style.opacity = '1'; b.textContent = '🎲 対戦カード抽選を開始'; b.classList.add('matchmaking-active'); } else { b.style.opacity = '0.5'; b.textContent = '🎲 対戦カード抽選（締切後に有効化）'; b.classList.remove('matchmaking-active'); } }
    
    // 抽選会場ボタンの状態更新
    function updateLotteryVenueButton() {
      const btn = document.getElementById('lotteryVenueBtn');
      const sub = document.getElementById('lotteryBtnSub');
      const entrance = document.getElementById('lotteryEntrance');
      const lotteryArena = document.getElementById('lotteryArena');
      if (!btn) return;
      
      // 大会がない場合はボタンエリアごと非表示
      if (!appState.tournament) {
        if (entrance) entrance.style.display = 'none';
        btn.disabled = true;
        return;
      }
      
      // 既に抽選会場内にいる場合は「抽選会場へ」ボタンを非表示のまま
      if (lotteryArena && lotteryArena.classList.contains('active')) {
        if (entrance) entrance.style.display = 'none';
        return;
      }
      
      // 抽選会場に入っていない場合のみボタンを表示
      if (entrance) entrance.style.display = '';
      
      const dl = appState.tournament?.deadline;
      if (dl) {
        const d = dl.toDate ? dl.toDate() : new Date(dl);
        if (new Date() >= d) {
          btn.disabled = false;
          if (sub) sub.style.display = 'none';
        } else {
          btn.disabled = true;
          if (sub) sub.style.display = '';
        }
      } else {
        btn.disabled = true;
        if (sub) sub.style.display = '';
      }
    }
    
    // 抽選会場へ移動
    function enterLotteryVenue() {
      const dl = appState.tournament?.deadline;
      if (!dl) { showToast('大会が設定されていません', 'error'); return; }
      const d = dl.toDate ? dl.toDate() : new Date(dl);
      if (new Date() < d) { showToast('締切日時以降に解放されます', 'error'); return; }

      // BGMをバトルマッチに切り替え
      switchToBattleBGM();

      // 入場ボタンと事前リストを非表示
      document.getElementById('lotteryEntrance').style.display = 'none';
      document.getElementById('preArenaList').style.display = 'none';

      // 抽選会場を表示（style.displayをクリアしてCSSのactiveクラスを有効にする）
      const lotteryArena = document.getElementById('lotteryArena');
      lotteryArena.style.display = '';
      lotteryArena.classList.add('active');

      // ゲームドロップダウン表示
      showGameDropdown();

      // 管理者のみルーレット操作ボタン表示
      const isAdmin = appState.isAdmin || appState.tournament?.admin_device === appState.deviceId;
      if (isAdmin) {
        document.getElementById('rouletteAdminControls').style.display = 'flex';
      } else {
        document.getElementById('rouletteAdminControls').style.display = 'none';
      }

      // 22人以上でグループ未割り当ての場合、管理者なら自動でグループ分け
      if (isAdmin && appState.entries.length >= 22 && !appState.tournament?.groups_assigned) {
        assignGroups();
      }

      // グループフェーズの場合はタブとアクティブグループを設定
      if (appState.tournament?.group_phase) {
        appState.activeGroup = appState.tournament.active_group || 'A';
        appState.groupPhase = appState.tournament.group_phase;
        renderGroupTabs();
      }

      // トーナメント表ボタンは全ユーザーに表示
      updateBracketControls();

      playClick();
      appendLog('抽選会場に入場しました');
    }
    function updateEntriesDisplay() {
      const list = document.getElementById('participantList');
      const listPre = document.getElementById('participantListPre');
      const listCountEl = document.getElementById('listCount');
      const listCountPreEl = document.getElementById('listCountPre');

      if (listCountPreEl) listCountPreEl.textContent = appState.entries.length;

      const matchingIds = appState.matchingIds || [];

      // Arena list: filter by active group
      const arenaEntries = getGroupFilteredEntries();
      if (listCountEl) listCountEl.textContent = arenaEntries.length;

      const buildRow = (e) => {
        const isMatching = matchingIds.includes(e.entry_id);
        const hasSeed = e.has_seed;
        const statusText = e.status === 'LOST' ? '敗退' : (hasSeed ? '🎖️シード' : '参加中');
        const statusClass = e.status === 'LOST' ? 'status-lost' : (hasSeed ? 'status-seed' : 'status-active');
        const groupLabel = e.group ? ' [' + e.group + ']' : '';
        return '<div class="participant-row' + (isMatching ? ' matching' : '') + '"><div class="participant-id">ID-' + String(e.entry_id).padStart(2,'0') + '</div><div class="participant-icon">' + (e.icon_url ? '<img src="' + e.icon_url + '">' : '👤') + '</div><div>' + escapeHtml(e.username) + groupLabel + (isMatching ? ' ⚔️' : '') + '</div><div><span class="status-badge ' + statusClass + '">' + statusText + '</span></div></div>';
      };

      const arenaHtml = arenaEntries.length === 0
        ? '<div style="text-align:center;padding:1.5rem;color:var(--text-dim);">参加者はいません</div>'
        : arenaEntries.map(buildRow).join('');

      const preHtml = appState.entries.length === 0
        ? '<div style="text-align:center;padding:1.5rem;color:var(--text-dim);">参加者はいません</div>'
        : appState.entries.map(buildRow).join('');

      if (list) list.innerHTML = arenaHtml;
      if (listPre) listPre.innerHTML = preHtml;

      // Update group tabs if visible
      renderGroupTabs();
    }
    function updateEntryScreen() {
      const my = appState.entries.find(e => e.device_id === appState.deviceId);
      const dl = appState.tournament?.deadline;
      const past = dl && new Date() > (dl.toDate ? dl.toDate() : new Date(dl));
      if (my) { document.getElementById('myEntryDisplay').style.display = 'block'; document.getElementById('entryForm').style.display = 'none'; document.getElementById('myEntryName').textContent = my.username; document.getElementById('myEntryId').textContent = ' (ID-' + String(my.entry_id).padStart(2,'0') + ')'; }
      else { document.getElementById('myEntryDisplay').style.display = past ? 'block' : 'none'; document.getElementById('entryForm').style.display = past ? 'none' : 'block'; if (past) document.getElementById('myEntryDisplay').innerHTML = '<div class="my-entry-box"><p style="color:var(--hud-red);">締切日時を過ぎています</p></div>'; }
    }
    function updateRouletteWheel() {
      const w = document.getElementById('wheelInner');
      const a = getGroupFilteredEntries().filter(e => e.status !== 'LOST');
      if (a.length === 0) { w.innerHTML = ''; return; }
      w.innerHTML = a.map((e,i) => {
        const hasSeed = e.has_seed;
        const style = hasSeed ? 'color:#ffa500;' : '';
        const seedMark = hasSeed ? '🎖️' : '';
        return '<div class="wheel-segment" style="transform:rotate(' + ((360/a.length)*i) + 'deg);' + style + '">' + seedMark + 'ID-' + String(e.entry_id).padStart(2,'0') + '</div>';
      }).join('');
    }
    function updateVsDisplay(p1, p2) { 
      document.getElementById('vsPlayer1Id').textContent = p1 ? 'ID-' + String(p1.entry_id).padStart(2,'0') : '-'; 
      document.getElementById('vsPlayer1Name').textContent = p1 ? p1.username : '-'; 
      document.getElementById('vsPlayer1Icon').innerHTML = p1?.icon_url ? '<img src="' + p1.icon_url + '" style="width:100%;height:100%;object-fit:cover;">' : '<svg class="silhouette-icon" viewBox="0 0 100 120"><circle cx="50" cy="30" r="22"/><path d="M10 120 Q10 70 50 65 Q90 70 90 120Z"/></svg>';
      document.getElementById('vsPlayer2Id').textContent = p2 ? 'ID-' + String(p2.entry_id).padStart(2,'0') : '-';
      document.getElementById('vsPlayer2Name').textContent = p2 ? p2.username : '-';
      document.getElementById('vsPlayer2Icon').innerHTML = p2?.icon_url ? '<img src="' + p2.icon_url + '" style="width:100%;height:100%;object-fit:cover;">' : '<svg class="silhouette-icon" viewBox="0 0 100 120"><circle cx="50" cy="30" r="22"/><path d="M10 120 Q10 70 50 65 Q90 70 90 120Z"/></svg>'; 
      
      // 勝利ボタンの名前を更新
      const w1 = document.getElementById('winner1Name');
      const w2 = document.getElementById('winner2Name');
      if (w1) w1.textContent = p1 ? p1.username : '-';
      if (w2) w2.textContent = p2 ? p2.username : '-';
      
      // 現在のマッチ表示を更新
      const matchDisplay = document.getElementById('currentMatchDisplay');
      const match1 = document.getElementById('currentMatch1');
      const match2 = document.getElementById('currentMatch2');
      if (matchDisplay && match1 && match2) {
        if (p1 && p2) {
          matchDisplay.style.display = 'block';
          match1.textContent = p1.username;
          match2.textContent = p2.username;
        } else {
          matchDisplay.style.display = 'none';
        }
      }
      
      // 参加者リストでマッチング中をハイライト
      appState.matchingIds = (p1 && p2) ? [p1.entry_id, p2.entry_id] : [];
      updateEntriesDisplay();
    }
    function filterParticipants(q) { document.querySelectorAll('#participantList .participant-row').forEach(r => { r.style.display = r.textContent.toLowerCase().includes(q.toLowerCase()) ? '' : 'none'; }); }

    let calendarDate = new Date(), calendarSelectedDate = null, calendarTarget = null;
    function openCalendar(target) { calendarTarget = target; calendarDate = new Date(); calendarSelectedDate = null; document.getElementById('calendarHour').value = '12'; document.getElementById('calendarMinute').value = '00'; renderCalendar(); updateCalendarDisplay(); document.getElementById('calendarModal').classList.add('active'); }
    function closeCalendar() { document.getElementById('calendarModal').classList.remove('active'); }
    function changeMonth(d) { calendarDate.setMonth(calendarDate.getMonth() + d); renderCalendar(); }
    function renderCalendar() {
      const y = calendarDate.getFullYear(), m = calendarDate.getMonth();
      document.getElementById('calendarMonthYear').textContent = y + '年 ' + (m + 1) + '月';
      const c = document.getElementById('calendarDays'); c.innerHTML = '';
      const first = new Date(y, m, 1).getDay(), days = new Date(y, m + 1, 0).getDate(), today = new Date(); today.setHours(0,0,0,0);
      for (let i = 0; i < first; i++) { const e = document.createElement('div'); e.className = 'calendar-day empty'; c.appendChild(e); }
      for (let d = 1; d <= days; d++) {
        const cell = document.createElement('div'); cell.className = 'calendar-day'; cell.textContent = d;
        const cd = new Date(y, m, d); cd.setHours(0,0,0,0);
        if (cd < today) { cell.classList.add('disabled'); } else { cell.onclick = () => { calendarSelectedDate = new Date(y, m, d); renderCalendar(); updateCalendarDisplay(); playClick(); }; cell.onmouseenter = playHover; }
        if (cd.getTime() === today.getTime()) cell.classList.add('today');
        if (calendarSelectedDate && calendarSelectedDate.getFullYear() === y && calendarSelectedDate.getMonth() === m && calendarSelectedDate.getDate() === d) cell.classList.add('selected');
        c.appendChild(cell);
      }
    }
    function updateCalendarDisplay() { const disp = document.getElementById('calendarSelectedDisplay'); if (calendarSelectedDate) { const h = document.getElementById('calendarHour').value.padStart(2,'0'), mi = document.getElementById('calendarMinute').value.padStart(2,'0'); disp.textContent = calendarSelectedDate.getFullYear() + '/' + String(calendarSelectedDate.getMonth()+1).padStart(2,'0') + '/' + String(calendarSelectedDate.getDate()).padStart(2,'0') + ' ' + h + ':' + mi; } else { disp.textContent = '日付を選択してください'; } }
    document.getElementById('calendarHour')?.addEventListener('input', updateCalendarDisplay);
    document.getElementById('calendarMinute')?.addEventListener('input', updateCalendarDisplay);
    function confirmCalendar() { if (!calendarSelectedDate) { showToast('日付を選択してください', 'error'); return; } const h = parseInt(document.getElementById('calendarHour').value) || 0, mi = parseInt(document.getElementById('calendarMinute').value) || 0; const dt = new Date(calendarSelectedDate.getFullYear(), calendarSelectedDate.getMonth(), calendarSelectedDate.getDate(), h, mi); if (dt <= new Date()) { showToast('現在より後の日時を選択してください', 'error'); return; } const str = dt.toLocaleString('ja-JP', {year:'numeric',month:'numeric',day:'numeric',hour:'2-digit',minute:'2-digit'}); if (calendarTarget === 'setup') { document.getElementById('setupDeadline').value = dt.toISOString(); document.getElementById('setupDeadlineBtn').textContent = str; } playClick(); closeCalendar(); }
    document.addEventListener('DOMContentLoaded', () => { setTimeout(addSounds, 100); initBGM(); initFirebase(); updateHudVisibility(); });
  </script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script>
    const firebaseConfig = { apiKey: "AIzaSyCNGRa4DCOM595aM5Exor5BF6oPUvg1TIY", authDomain: "tournament-app-a0837.firebaseapp.com", projectId: "tournament-app-a0837", storageBucket: "tournament-app-a0837.firebasestorage.app", messagingSenderId: "514905483124", appId: "1:514905483124:web:1882493de273598b0a2e21" };
    let db = null;
    
    // スパム対策：クールダウン管理
    const COOLDOWN_TIME = 5 * 60 * 1000; // 5分（ミリ秒）
    const COOLDOWN_THRESHOLD = 3; // 3回
    const COOLDOWN_WINDOW = 5 * 60 * 1000; // 5分以内
    
    // クールダウン状態チェック
    async function checkCooldown(type) {
      if (!db) return { blocked: false };
      const docId = type === 'user' ? appState.deviceId : 'admin_' + appState.deviceId;
      try {
        const doc = await db.collection('cooldowns').doc(docId).get();
        if (doc.exists) {
          const data = doc.data();
          const expiry = data.expiry?.toDate?.() || new Date(data.expiry);
          if (new Date() < expiry) {
            const remaining = Math.ceil((expiry - new Date()) / 1000 / 60);
            return { blocked: true, remaining: remaining };
          } else {
            // 期限切れなら削除
            await db.collection('cooldowns').doc(docId).delete();
          }
        }
      } catch (e) { console.error('Cooldown check error:', e); }
      return { blocked: false };
    }
    
    // 操作ログを記録して異常検知
    async function recordAction(type, actionName) {
      if (!db) return false;
      const docId = type === 'user' ? appState.deviceId : 'admin_' + appState.deviceId;
      const now = new Date();
      const windowStart = new Date(now.getTime() - COOLDOWN_WINDOW);
      
      try {
        // 操作ログを追加
        await db.collection('action_logs').add({
          device_id: appState.deviceId,
          type: type,
          action: actionName,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        // 5分以内の操作回数をカウント
        const snap = await db.collection('action_logs')
          .where('device_id', '==', appState.deviceId)
          .where('type', '==', type)
          .where('timestamp', '>=', windowStart)
          .get();
        
        if (snap.size >= COOLDOWN_THRESHOLD) {
          // クールダウン発動
          const expiry = new Date(now.getTime() + COOLDOWN_TIME);
          await db.collection('cooldowns').doc(docId).set({
            device_id: appState.deviceId,
            type: type,
            reason: actionName,
            expiry: expiry,
            created_at: firebase.firestore.FieldValue.serverTimestamp()
          });
          
          // 異常通知をログに記録（管理者向け）
          await db.collection('spam_alerts').add({
            device_id: appState.deviceId,
            type: type,
            username: type === 'user' ? (appState.entries.find(e => e.device_id === appState.deviceId)?.username || '不明') : appState.adminName,
            action_count: snap.size,
            cooldown_minutes: 5,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
          
          appendLog('⚠️ 異常検知: クールダウン発動');
          return true; // クールダウン発動
        }
      } catch (e) { console.error('Record action error:', e); }
      return false;
    }
    
    // 古い操作ログをクリーンアップ（5分以上前のもの）
    async function cleanupOldActionLogs() {
      if (!db) return;
      const cutoff = new Date(Date.now() - COOLDOWN_WINDOW - 60000);
      try {
        const snap = await db.collection('action_logs')
          .where('timestamp', '<', cutoff)
          .limit(50)
          .get();
        if (!snap.empty) {
          const batch = db.batch();
          snap.forEach(doc => batch.delete(doc.ref));
          await batch.commit();
        }
      } catch (e) { console.error('Cleanup error:', e); }
    }
    
    function initFirebase() { try { firebase.initializeApp(firebaseConfig); db = firebase.firestore(); console.log('Firebase OK'); loadData(); initLogListener(); setInterval(cleanupOldActionLogs, 60000); } catch (e) { console.error('Firebase error:', e); updateTournamentDisplay(); } }
    function loadData() { 
      if (!db) return; 
      
      // トーナメント情報の監視（ルーレット状態含む）
      db.collection('tournaments').doc('current').onSnapshot(doc => { 
        if (doc.exists) { 
          const data = doc.data();
          const prevRouletteState = appState.tournament?.roulette_state;
          appState.tournament = data; 
          
          if (data.admin_device === appState.deviceId) { 
            appState.isAdmin = true; 
            appState.adminName = data.admin_name; 
          }
          
          // ルーレット状態の同期（管理者以外のデバイス）
          if (data.roulette_state && data.admin_device !== appState.deviceId) {
            const newState = data.roulette_state;
            const prevTimestamp = prevRouletteState?.timestamp?.toMillis?.() || 0;
            const newTimestamp = newState.timestamp?.toMillis?.() || 0;

            if (newTimestamp > prevTimestamp) {
              handleRouletteSync(newState);
            }
          }

          // グループ状態の同期
          if (data.group_phase) {
            appState.groupPhase = data.group_phase;
            if (data.group_phase === 'merged') {
              appState.activeGroup = null;
            } else {
              appState.activeGroup = data.active_group || appState.activeGroup;
            }
            renderGroupTabs();
          }

          updateTournamentDisplay(); 
        } else {
          // 大会データが存在しない場合
          const hadTournament = appState.tournament !== null;
          appState.tournament = null;
          
          // 以前は大会があったが今はない → リセット（大会終了）
          if (hadTournament) {
            resetAfterTournamentEnd();
          } else {
            // 初期状態（大会がない状態）- 表示だけ更新
            updateTournamentDisplay();
          }
        }
      }); 
      
      // エントリー情報の監視
      db.collection('entries').orderBy('entry_id', 'asc').onSnapshot(snap => { 
        appState.entries = snap.docs.map(d => ({ id: d.id, ...d.data() })); 
        updateEntriesDisplay(); 
        updateRouletteWheel(); 
        updateTournamentDisplay(); 
        updateBracketControls(); 
        if (bracketMode) generateBracket(); 
      }); 
      
      // マッチ情報の監視
      db.collection('matches').orderBy('created_at', 'asc').onSnapshot(snap => {
        appState.matches = snap.docs.map(d => ({ id: d.id, ...d.data() }));
        updateBracketControls();
        if (bracketMode) generateBracket();
        // 全対戦カード確定チェック（管理者のみ）
        if (appState.isAdmin) checkAllMatchupsDecided();
      });

      // ゲーム情報の監視（tournaments/games_registryに保存）
      db.collection('tournaments').doc('games_registry').onSnapshot(doc => {
        if (doc.exists) {
          const data = doc.data();
          appState.gameAuthHash = data._auth_hash || null;
          appState.games = Object.entries(data).filter(([id]) => !id.startsWith('_')).map(([id, g]) => ({ id, ...g })).sort((a, b) => {
            const ta = a.created_at || '';
            const tb = b.created_at || '';
            return ta < tb ? -1 : ta > tb ? 1 : 0;
          });
          // 認証IDが未設定の場合、管理者なら自動設定
          if (!data._auth_hash && appState.isAdmin) {
            hashString('GmReg847').then(hash => {
              db.collection('tournaments').doc('games_registry').set({ _auth_hash: hash }, { merge: true });
            });
          }
        } else {
          appState.games = [];
          appState.gameAuthHash = null;
        }
        renderGameList();
        renderGameDropdown();
        updateGameAuthStatus();
      });
    }
    
    // 大会終了後のリセット処理（全端末共通）
    function resetAfterTournamentEnd() {
      console.log('大会データが削除されました。リセットします。');

      // 管理者が自分で終了した場合は、管理者側の画面遷移を行わない
      if (tournamentEndedLocally) return;

      // BGMを通常に戻す
      switchToNormalBGM();
      
      // ローカル状態を完全リセット
      appState.tournament = null;
      appState.entries = [];
      appState.matches = [];
      appState.selectedPlayer1 = null;
      appState.selectedPlayer2 = null;
      appState.matchingIds = [];
      appState.activeGroup = null;
      appState.groupPhase = null;
      appState.isAdmin = false;
      appState.adminName = null;
      bracketMode = false;

      // 管理者情報をlocalStorageから削除
      localStorage.removeItem('tournament_admin_name');

      // グループタブを非表示
      const groupTabsContainer = document.getElementById('groupTabsContainer');
      if (groupTabsContainer) groupTabsContainer.style.display = 'none';

      // HUDログをクリア
      hudLogs.length = 0;
      
      // 画面を更新
      updateTournamentDisplay();
      updateEntriesDisplay();
      updateHudVisibility();

      // トースト表示
      showToast('大会が終了しました', 'info');
      
      // 画面履歴をクリア
      screenHistory = [];
      
      // すべての画面を非表示
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById('titleScreen').classList.add('active');
      currentScreen = 'titleScreen';
      
      // ヘッダーを非表示
      document.getElementById('mainHeader').classList.remove('visible');
      document.getElementById('backBtn').classList.remove('visible');
      
      // 抽選会場の状態を完全リセット
      const bracketContainer = document.getElementById('bracketContainer');
      if (bracketContainer) bracketContainer.classList.remove('active');
      
      const lotteryArena = document.getElementById('lotteryArena');
      if (lotteryArena) {
        lotteryArena.style.display = 'none';
        lotteryArena.style.gridTemplateColumns = '';
      }
      
      const lotteryEntrance = document.getElementById('lotteryEntrance');
      if (lotteryEntrance) lotteryEntrance.style.display = '';
      
      const preArenaList = document.getElementById('preArenaList');
      if (preArenaList) preArenaList.style.display = '';
      
      const rouletteMain = document.querySelector('.lottery-main');
      if (rouletteMain) rouletteMain.style.display = 'flex';
      
      const lotterySidebar = document.querySelector('.lottery-sidebar');
      if (lotterySidebar) lotterySidebar.style.display = '';
      
      // ルーレット関連をリセット
      const rouletteAdminControls = document.getElementById('rouletteAdminControls');
      if (rouletteAdminControls) rouletteAdminControls.style.display = 'none';
      
      const bracketControls = document.getElementById('bracketControls');
      if (bracketControls) bracketControls.style.display = 'none';
      
      const wheelInner = document.getElementById('wheelInner');
      if (wheelInner) wheelInner.style.transform = 'rotate(0deg)';
      
      // VS表示をリセット
      if (typeof updateVsDisplay === 'function') updateVsDisplay(null, null);
      if (typeof disableWinnerSelection === 'function') disableWinnerSelection();

      // 対戦カード抽選ボタンをリセット
      updateMatchmakingButton();

      // HUD表示状態を更新
      updateHudVisibility();
      
      // ボタン状態を更新
      updateTournamentViewButton();
      updateLotteryVenueButton();
    }
    async function registerAdmin() { 
      const btn = document.querySelector('#adminScreen .submit-btn');
      if (btn) btn.disabled = true; // 二重クリック防止
      
      try {
        // クールダウンチェック
        const cd = await checkCooldown('admin');
        if (cd.blocked) { 
          showToast('短時間で登録・解除を繰り返したため、しばらくお待ちください（残り' + cd.remaining + '分）', 'error'); 
          if (btn) btn.disabled = false;
          return; 
        }
        
        const n = document.getElementById('adminNameInput').value.trim(); 
        const e = document.getElementById('adminNameError'); 
        if (!n) { 
          e.textContent = '管理者名を入力してください'; 
          e.classList.add('visible'); 
          if (btn) btn.disabled = false;
          return; 
        } 
        e.classList.remove('visible'); 
        localStorage.setItem('tournament_admin_name', n); 
        appState.adminName = n; 
        appState.isAdmin = true; 
        
        // 画面遷移（ログは大会設定完了時に出す）
        screenHistory.push(currentScreen); 
        document.getElementById(currentScreen).classList.remove('active'); 
        document.getElementById('adminSetupScreen').classList.add('active'); 
        currentScreen = 'adminSetupScreen'; 
        document.getElementById('mainHeader').classList.add('visible'); 
        document.getElementById('backBtn').classList.add('visible');
        if (btn) btn.disabled = false; // 成功後に再有効化
      } catch (err) {
        console.error('registerAdmin error:', err);
        if (btn) btn.disabled = false;
      }
    }
    // ゲーム登録・管理
    function toggleAuthIdVisibility() {
      var input = document.getElementById('gameRegAuthId');
      var btn = document.getElementById('authIdToggleBtn');
      if (input.type === 'password') {
        input.type = 'text';
        btn.textContent = '🔒';
      } else {
        input.type = 'password';
        btn.textContent = '👁️';
      }
    }
    async function hashString(str) {
      const data = new TextEncoder().encode(str);
      const buf = await crypto.subtle.digest('SHA-256', data);
      return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
    }
    async function registerGame() {
      if (!db) { showToast('データベースに接続できません。ページを再読み込みしてください。', 'error'); return; }
      if (!appState.isAdmin) { showToast('管理者として登録してください', 'error'); return; }
      // クールダウンチェック
      const cd = await checkCooldown('admin');
      if (cd.blocked) { showToast('短時間で操作を繰り返したため、しばらくお待ちください（残り' + cd.remaining + '分）', 'error'); return; }
      const nameEl = document.getElementById('gameRegName');
      const urlEl = document.getElementById('gameRegUrl');
      const authEl = document.getElementById('gameRegAuthId');
      const errEl = document.getElementById('gameRegError');
      const name = nameEl.value.trim();
      const url = urlEl.value.trim();
      const authId = authEl.value.trim();
      errEl.classList.remove('visible');
      if (!name) { errEl.textContent = 'ゲーム名を入力してください'; errEl.classList.add('visible'); return; }
      if (!url) { errEl.textContent = 'URLを入力してください'; errEl.classList.add('visible'); return; }
      try { new URL(url); } catch { errEl.textContent = '有効なURLを入力してください'; errEl.classList.add('visible'); return; }
      if (!authId) { errEl.textContent = '認証IDを入力してください'; errEl.classList.add('visible'); return; }
      if (appState.games.length >= 20) { errEl.textContent = 'ゲーム登録は最大20件までです'; errEl.classList.add('visible'); return; }
      if (appState.games.find(g => g.name === name)) { errEl.textContent = 'このゲーム名は既に登録済みです'; errEl.classList.add('visible'); return; }
      if (appState.games.find(g => g.url === url)) { errEl.textContent = 'このURLは既に登録済みです'; errEl.classList.add('visible'); return; }
      // 認証IDの検証
      const inputHash = await hashString(authId);
      if (appState.gameAuthHash) {
        if (inputHash !== appState.gameAuthHash) {
          errEl.textContent = '認証IDが一致しません'; errEl.classList.add('visible'); return;
        }
      }
      // 操作記録
      const triggered = await recordAction('admin', 'register_game');
      if (triggered) { showToast('短時間でゲーム登録を繰り返したため、しばらくお待ちください', 'error'); return; }
      try {
        const gameId = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        const gameData = {};
        gameData[gameId] = { name, url, admin_device: appState.deviceId, created_at: new Date().toISOString() };
        if (!appState.gameAuthHash) {
          // 初回：認証IDハッシュも一緒に保存
          gameData._auth_hash = inputHash;
        }
        await db.collection('tournaments').doc('games_registry').set(gameData, { merge: true });
        nameEl.value = ''; urlEl.value = ''; authEl.value = '';
        showToast('ゲーム「' + name + '」を登録しました');
      } catch (e) { console.error('Game register error:', e); showToast('登録に失敗しました: ' + e.message, 'error'); }
    }
    async function removeGame(gameId, gameName) {
      if (!db || !appState.isAdmin) return;
      // クールダウンチェック
      const cd = await checkCooldown('admin');
      if (cd.blocked) { showToast('短時間で操作を繰り返したため、しばらくお待ちください（残り' + cd.remaining + '分）', 'error'); return; }
      if (!confirm('「' + gameName + '」を削除しますか？')) return;
      // 操作記録
      const triggered = await recordAction('admin', 'remove_game');
      if (triggered) { showToast('短時間でゲーム削除を繰り返したため、しばらくお待ちください', 'error'); return; }
      try {
        const deleteData = {};
        deleteData[gameId] = firebase.firestore.FieldValue.delete();
        await db.collection('tournaments').doc('games_registry').update(deleteData);
        showToast('「' + gameName + '」を削除しました');
      } catch (e) { console.error(e); showToast('削除に失敗しました', 'error'); }
    }
    function updateGameAuthStatus() {
      var el = document.getElementById('gameAuthStatus');
      if (!el) return;
      if (appState.gameAuthHash) {
        el.innerHTML = '<span style="color:var(--hud-green);">🔒 認証ID: 設定済み</span>' +
          ' <button onclick="verifyAuthId()" style="background:none;border:1px solid var(--hud-green-dim);color:var(--text-dim);padding:0.15rem 0.5rem;border-radius:3px;cursor:pointer;font-size:0.7rem;margin-left:0.3rem;">確認</button>';
      } else {
        el.innerHTML = '<span style="color:var(--hud-red);">🔓 認証ID: 未設定（次回登録時に設定されます）</span>';
      }
    }
    async function verifyAuthId() {
      var input = prompt('認証IDを入力して確認:');
      if (!input) return;
      var hash = await hashString(input.trim());
      if (hash === appState.gameAuthHash) {
        showToast('認証ID: 一致しました ✓', 'success');
      } else {
        showToast('認証ID: 一致しません ✗', 'error');
      }
    }
    function renderGameList() {
      const container = document.getElementById('gameListAdmin');
      if (!container) return;
      if (appState.games.length === 0) { container.innerHTML = '<p style="color:var(--text-dim);font-size:0.8rem;text-align:center;">登録されたゲームはありません</p>'; return; }
      let html = '<div style="font-size:0.8rem;color:var(--text-dim);margin-bottom:0.4rem;">登録済みゲーム (' + appState.games.length + '件):</div>';
      html += '<div style="display:flex;align-items:center;gap:0.5rem;">';
      html += '<select id="gameListSelect" class="form-input" style="flex:1;cursor:pointer;">';
      appState.games.forEach(g => {
        html += '<option value="' + escapeHtml(g.id) + '" data-name="' + escapeHtml(g.name) + '">' + escapeHtml(g.name) + '</option>';
      });
      html += '</select>';
      html += '<button onclick="removeSelectedGame()" style="background:none;border:1px solid var(--hud-red);color:var(--hud-red);padding:0.4rem 0.8rem;border-radius:3px;cursor:pointer;font-size:0.75rem;flex-shrink:0;white-space:nowrap;">削除</button>';
      html += '</div>';
      container.innerHTML = html;
    }
    function removeSelectedGame() {
      const sel = document.getElementById('gameListSelect');
      if (!sel || !sel.value) return;
      const gameId = sel.value;
      const gameName = sel.options[sel.selectedIndex].dataset.name;
      removeGame(gameId, gameName);
    }
    // ゲーム選択パネルの開閉
    function toggleGameSelectPanel() {
      var panel = document.getElementById('gameSelectPanel');
      var arrow = document.getElementById('gameSelectArrow');
      if (!panel) return;
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        if (arrow) arrow.classList.add('open');
      } else {
        panel.style.display = 'none';
        if (arrow) arrow.classList.remove('open');
      }
    }
    // ゲーム選択リストを更新（表示/非表示は制御しない）
    function updateGameDropdownOptions() {
      var list = document.getElementById('gameSelectList');
      if (!list) return;
      var tournamentGame = appState.tournament?.game_name || '';
      var normalize = function(s) { return s.replace(/\s/g, '').toLowerCase(); };
      var html = '';
      appState.games.forEach(function(g) {
        var isMatch = normalize(g.name) === normalize(tournamentGame);
        if (isMatch) {
          html += '<div class="game-select-item" onclick="openGameByUrl(\'' + escapeHtml(g.url).replace(/'/g, "\\'") + '\')">';
          html += '<div class="game-select-item-icon">🎮</div>';
          html += '<div class="game-select-item-name">' + escapeHtml(g.name) + '</div>';
          html += '<div class="game-select-item-badge">PLAY</div>';
          html += '</div>';
        } else {
          html += '<div class="game-select-item disabled">';
          html += '<div class="game-select-item-icon" style="opacity:0.4;">🎮</div>';
          html += '<div class="game-select-item-name">' + escapeHtml(g.name) + '</div>';
          html += '<div class="game-select-item-tag">対象外</div>';
          html += '</div>';
        }
      });
      if (html === '') {
        html = '<div style="padding:0.6rem;text-align:center;color:var(--text-dim);font-size:0.8rem;">対象ゲームなし</div>';
      }
      list.innerHTML = html;
    }
    // 抽選会場でゲーム選択エリアを表示する（アリーナがアクティブな時のみ）
    function showGameDropdown() {
      var area = document.getElementById('gameDropdownArea');
      if (!area) return;
      var arenaActive = document.getElementById('lotteryArena')?.classList.contains('active');
      if (!arenaActive || appState.games.length === 0) { area.style.display = 'none'; return; }
      updateGameDropdownOptions();
      area.style.display = 'block';
    }
    // ゲーム選択時：隠し<a>タグ経由で新タブを開く
    function openGameByUrl(url) {
      var link = document.getElementById('gameHiddenLink');
      if (!link || !url) return;
      link.href = url;
      link.click();
      // パネルを閉じる
      var panel = document.getElementById('gameSelectPanel');
      var arrow = document.getElementById('gameSelectArrow');
      if (panel) panel.style.display = 'none';
      if (arrow) arrow.classList.remove('open');
    }
    // 後方互換: openSelectedGame (もう使われないが念のため)
    function openSelectedGame() {}
    // 後方互換用
    function renderGameDropdown() {
      var arenaActive = document.getElementById('lotteryArena')?.classList.contains('active');
      if (arenaActive) { showGameDropdown(); }
    }

    function saveTournamentSettings() { const gn = document.getElementById('setupGameName').value.trim(); const dl = document.getElementById('setupDeadline').value; const ge = document.getElementById('setupGameNameError'); const de = document.getElementById('setupDeadlineError'); ge.classList.remove('visible'); de.classList.remove('visible'); let err = false; if (!gn) { ge.textContent = 'ゲーム名を入力してください'; ge.classList.add('visible'); err = true; } if (!dl) { de.textContent = '締切日時を選択してください'; de.classList.add('visible'); err = true; } if (err) return; appState.tournament = { admin_name: appState.adminName, admin_device: appState.deviceId, game_name: gn, deadline: new Date(dl) }; appendLog(appState.adminName + 'が管理者になり、トーナメント「' + gn + '」を作成しました'); if (db) { db.collection('tournaments').doc('current').set({ admin_name: appState.adminName, admin_device: appState.deviceId, game_name: gn, deadline: new Date(dl), updated_at: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true }).catch(e => console.error(e)); } updateTournamentDisplay(); showModal('settingsCompleteModal'); }
    async function submitEntry() { 
      // クールダウンチェック
      const cd = await checkCooldown('user');
      if (cd.blocked) { showToast('短時間で登録・解除を繰り返したため、しばらくお待ちください（残り' + cd.remaining + '分）', 'error'); return; }
      
      if (!appState.tournament?.deadline) { showToast('締切日時が未設定です', 'error'); return; } const d = appState.tournament.deadline.toDate ? appState.tournament.deadline.toDate() : new Date(appState.tournament.deadline); if (new Date() > d) { showToast('締切を過ぎています', 'error'); return; } const n = document.getElementById('usernameInput').value.trim(); const e = document.getElementById('usernameError'); if (!n) { e.textContent = 'ユーザーネームを入力してください'; e.classList.add('visible'); return; } if (appState.entries.find(x => x.username === n)) { e.textContent = 'このユーザー名は既に使用されています'; e.classList.add('visible'); return; } if (appState.entries.find(x => x.device_id === appState.deviceId)) { e.textContent = 'このデバイスは既に登録済みです'; e.classList.add('visible'); return; } if (appState.entries.length >= 100) { updateSystemNotice('参加上限に達しました'); showToast('参加上限に達しました', 'error'); return; } e.classList.remove('visible'); 
      
      // 操作記録
      const triggered = await recordAction('user', 'entry');
      if (triggered) { showToast('短時間で登録・解除を繰り返したため、しばらくお待ちください', 'error'); return; }
      
      const id = appState.entries.length + 1; const ic = document.getElementById('iconPreview').querySelector('img'); playClick(); const ne = { id: appState.deviceId, entry_id: id, username: n, device_id: appState.deviceId, icon_url: ic ? ic.src : null, status: 'ACTIVE' }; appState.entries.push(ne); appendLog(n + 'がエントリーしました'); if (db) { db.collection('entries').doc(appState.deviceId).set({ entry_id: id, username: n, device_id: appState.deviceId, icon_url: ic ? ic.src : null, status: 'ACTIVE', created_at: firebase.firestore.FieldValue.serverTimestamp() }).catch(x => console.error(x)); } updateEntriesDisplay(); updateTournamentDisplay(); document.getElementById('usernameInput').value = ''; clearIcon(); document.getElementById('entryCompleteInfo').textContent = n + ' (ID-' + String(id).padStart(2,'0') + ')'; showModal('entryCompleteModal'); 
    }
    function cancelEntry() { const my = appState.entries.find(e => e.device_id === appState.deviceId); if (!my) { showToast('エントリーしていません', 'error'); return; } const dl = appState.tournament?.deadline; if (dl) { const d = dl.toDate ? dl.toDate() : new Date(dl); if (new Date() >= d) { showToast('締切日時を過ぎているため解除できません', 'error'); return; } } showModal('confirmCancelEntryModal'); }
    async function executeCancelEntry() { 
      // クールダウンチェック
      const cd = await checkCooldown('user');
      if (cd.blocked) { hideModal('confirmCancelEntryModal'); showToast('短時間で登録・解除を繰り返したため、しばらくお待ちください（残り' + cd.remaining + '分）', 'error'); return; }
      
      // 操作記録
      const triggered = await recordAction('user', 'cancel_entry');
      if (triggered) { hideModal('confirmCancelEntryModal'); showToast('短時間で登録・解除を繰り返したため、しばらくお待ちください', 'error'); return; }
      
      playClick(); const myEntry = appState.entries.find(e => e.device_id === appState.deviceId); const username = myEntry ? myEntry.username : '不明'; const i = appState.entries.findIndex(e => e.device_id === appState.deviceId); if (i !== -1) appState.entries.splice(i, 1); appendLog(username + 'が登録解除しました'); if (db) db.collection('entries').doc(appState.deviceId).delete().catch(e => console.error(e)); updateEntriesDisplay(); updateTournamentDisplay(); updateEntryScreen(); updateCancelEntryButton(); hideModal('confirmCancelEntryModal'); showModal('cancelCompleteModal'); 
    }
    // ===== グループシステム =====
    function getGroupFilteredEntries() {
      if (!appState.tournament?.group_phase) return appState.entries;
      // 統合フェーズ: 全エントリーを返す（グループ区分なし）
      if (appState.tournament.group_phase === 'merged') return appState.entries;
      if (appState.activeGroup === 'finals') {
        const winners = appState.tournament?.group_winners || {};
        const winnerIds = Object.values(winners).map(w => w.entry_id);
        return appState.entries.filter(e => winnerIds.includes(e.entry_id));
      }
      if (appState.activeGroup) {
        return appState.entries.filter(e => e.group === appState.activeGroup);
      }
      return appState.entries;
    }
    function getGroupFilteredMatches() {
      if (!appState.tournament?.group_phase) return appState.matches;
      // 統合フェーズ: グループなしのマッチ（統合後に作られたもの）を返す
      if (appState.tournament.group_phase === 'merged') {
        return appState.matches.filter(m => !m.group || m.group === 'merged');
      }
      if (appState.activeGroup === 'finals') {
        return appState.matches.filter(m => m.group === 'finals');
      }
      if (appState.activeGroup) {
        return appState.matches.filter(m => m.group === appState.activeGroup);
      }
      return appState.matches;
    }

    function assignGroups() {
      if (!db) return Promise.resolve();
      const entries = appState.entries;
      if (entries.length <= 21) return Promise.resolve();

      const count = entries.length;
      const numGroups = Math.min(5, Math.ceil(count / 20));
      const groupNames = ['A', 'B', 'C', 'D', 'E'].slice(0, numGroups);

      const shuffled = [...entries].sort(() => Math.random() - 0.5);
      const batch = db.batch();
      shuffled.forEach((entry, i) => {
        const group = groupNames[i % numGroups];
        batch.update(db.collection('entries').doc(entry.id), { group: group });
      });
      batch.update(db.collection('tournaments').doc('current'), {
        groups_assigned: true,
        group_phase: 'group',
        active_group: groupNames[0],
        group_winners: {}
      });
      return batch.commit().then(() => {
        appState.activeGroup = groupNames[0];
        appState.groupPhase = 'group';
        showToast(numGroups + 'グループに分けました', 'success');
        appendLog('グループ分け完了: ' + numGroups + 'グループ（各最大20人）');
      });
    }

    function renderGroupTabs() {
      const container = document.getElementById('groupTabsContainer');
      const tabs = document.getElementById('groupTabs');
      const infoText = document.getElementById('groupInfoText');
      const bulkBtn = document.getElementById('groupBulkMatch');
      if (!container || !tabs) return;

      const phase = appState.tournament?.group_phase;
      if (!phase || phase === 'merged') {
        container.style.display = 'none';
        return;
      }

      container.style.display = '';
      const groups = [...new Set(appState.entries.map(e => e.group).filter(Boolean))].sort();
      if (groups.length === 0) { container.style.display = 'none'; return; }

      const activeGroup = appState.activeGroup || appState.tournament?.active_group || groups[0];
      const winners = appState.tournament?.group_winners || {};

      let html = '';
      groups.forEach(g => {
        const groupEntries = appState.entries.filter(e => e.group === g);
        const activeCount = groupEntries.filter(e => e.status !== 'LOST').length;
        const hasWinner = !!winners[g];
        const isActive = (phase === 'group' && g === activeGroup);
        html += '<div class="group-tab' + (isActive ? ' active' : '') + (hasWinner ? ' completed' : '') + '" onclick="selectGroup(\'' + g + '\')">';
        html += 'G-' + g + ' (' + activeCount + '/' + groupEntries.length + ')';
        if (hasWinner) html += ' ✓';
        html += '</div>';
      });

      // 決勝タブ
      const allGroupsDone = groups.length > 0 && Object.keys(winners).length === groups.length;
      if (phase === 'finals' || allGroupsDone) {
        const isFinalsActive = activeGroup === 'finals';
        html += '<div class="group-tab finals-tab' + (isFinalsActive ? ' active' : '') + '" onclick="selectGroup(\'finals\')">決勝</div>';
      }

      tabs.innerHTML = html;
      appState.activeGroup = activeGroup;

      // info text
      if (infoText) {
        if (activeGroup === 'finals') {
          const winnerCount = Object.keys(winners).length;
          infoText.textContent = '決勝: ' + winnerCount + '名のグループ勝者';
        } else {
          const ge = appState.entries.filter(e => e.group === activeGroup);
          const ac = ge.filter(e => e.status !== 'LOST').length;
          infoText.textContent = 'グループ' + activeGroup + ': 残り' + ac + '名';
          if (winners[activeGroup]) {
            infoText.textContent += ' (勝者: ' + winners[activeGroup].username + ')';
          }
        }
      }

      // bulk match button (admin only, group phase, not completed group)
      if (bulkBtn) {
        const isAdmin = appState.isAdmin || appState.tournament?.admin_device === appState.deviceId;
        if (isAdmin && activeGroup !== 'finals' && !winners[activeGroup]) {
          bulkBtn.style.display = '';
        } else if (isAdmin && activeGroup === 'finals' && phase === 'finals') {
          bulkBtn.style.display = '';
        } else {
          bulkBtn.style.display = 'none';
        }
      }
    }

    function selectGroup(group) {
      appState.activeGroup = group;
      if (db && appState.isAdmin) {
        db.collection('tournaments').doc('current').update({
          active_group: group,
          group_phase: group === 'finals' ? 'finals' : (appState.tournament?.group_phase || 'group')
        }).catch(e => {});
      }
      renderGroupTabs();
      updateEntriesDisplay();
      updateRouletteWheel();
      updateBracketControls();
      if (bracketMode) generateBracket();
    }

    async function bulkMatchGroup() {
      const isAdmin = appState.isAdmin || appState.tournament?.admin_device === appState.deviceId;
      if (!isAdmin || !db) return;

      const entries = getGroupFilteredEntries();
      const active = entries.filter(e => e.status !== 'LOST');
      const inMatch = getGroupFilteredMatches().filter(m => !m.winner_id);
      const inMatchIds = inMatch.flatMap(m => [m.player1_id, m.player2_id]);
      const available = active.filter(e => !inMatchIds.includes(e.entry_id) && !e.has_seed);

      if (available.length < 2) {
        showToast('マッチング可能な参加者が不足しています', 'error');
        return;
      }

      const shuffled = [...available].sort(() => Math.random() - 0.5);
      const batch = db.batch();
      let matchCount = 0;
      const groupTag = appState.activeGroup || null;

      for (let i = 0; i + 1 < shuffled.length; i += 2) {
        const ref = db.collection('matches').doc();
        batch.set(ref, {
          player1_id: shuffled[i].entry_id,
          player1_name: shuffled[i].username,
          player2_id: shuffled[i + 1].entry_id,
          player2_name: shuffled[i + 1].username,
          winner_id: null,
          round: 1,
          group: groupTag,
          created_at: firebase.firestore.FieldValue.serverTimestamp()
        });
        matchCount++;
      }

      if (shuffled.length % 2 === 1) {
        const lastPlayer = shuffled[shuffled.length - 1];
        batch.update(db.collection('entries').doc(lastPlayer.id), { has_seed: true });
      }

      await batch.commit();
      showToast(matchCount + '組の対戦カードを作成しました', 'success');
      appendLog('一括マッチメイク: ' + matchCount + '組');
    }
    // ===== グループシステムここまで =====

    function spinRoulette() {
      if (appState.isSpinning) return;
      const a = getGroupFilteredEntries().filter(e => e.status !== 'LOST');

      // 優勝者が決まっている場合は回せない
      if (a.length <= 1) {
        showToast('このグループは終了しています', 'error');
        return;
      }

      // 進行中の試合がある人を除外（グループフィルタ）
      const inMatch = getGroupFilteredMatches().filter(m => !m.winner_id);
      const inMatchIds = inMatch.flatMap(m => [m.player1_id, m.player2_id]);

      // 対戦可能なプレイヤー（敗退せず、進行中の試合がなく、シード権もない）
      const available = a.filter(e => !inMatchIds.includes(e.entry_id) && !e.has_seed);

      // 対戦可能な参加者がいない
      if (available.length === 0) {
        showToast('全ての対戦カードが確定済みです', 'info');
        return;
      }

      // 1人だけ残った場合 → 自動シード
      if (available.length === 1) {
        autoAssignSeed(available[0]);
        return;
      }

      if (available.length < 2) { showToast('対戦可能な参加者が不足しています', 'error'); return; }

      // 対戦カードを決定
      appState.isSpinning = true;
      document.getElementById('spinBtn').disabled = true;
      const s = [...available].sort(() => Math.random() - 0.5);
      appState.selectedPlayer1 = s[0];
      appState.selectedPlayer2 = s[1];

      const rotation = 1800 + Math.random() * 720;

      // Firestoreにルーレット状態を保存（他デバイスに同期）
      if (db) {
        db.collection('tournaments').doc('current').update({
          roulette_state: {
            spinning: true,
            rotation: rotation,
            player1_id: s[0].entry_id,
            player2_id: s[1].entry_id,
            seed_lottery: false,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          }
        }).catch(e => console.log('Roulette sync error:', e));
      }

      playSpinSound();

      document.getElementById('wheelInner').style.transform = 'rotate(' + rotation + 'deg)';
      setTimeout(() => {
        playVsSound();
        updateVsDisplay(appState.selectedPlayer1, appState.selectedPlayer2);
        appendLog(appState.selectedPlayer1.username + ' VS ' + appState.selectedPlayer2.username + ' の対戦が確定');

        // ルーレット完了 → 自動で対戦確定（Firestore保存）
        if (db) {
          db.collection('matches').add({
            player1_id: appState.selectedPlayer1.entry_id,
            player1_name: appState.selectedPlayer1.username,
            player2_id: appState.selectedPlayer2.entry_id,
            player2_name: appState.selectedPlayer2.username,
            winner_id: null,
            round: 1,
            group: appState.activeGroup || null,
            created_at: firebase.firestore.FieldValue.serverTimestamp()
          }).then(() => {
            enableWinnerSelection();
            showToast('対戦確定！勝者をクリックしてください', 'success');
            setTimeout(() => { checkAllMatchupsDecided(); }, 500);
          }).catch(e => showToast('エラー: ' + e.message, 'error'));

          db.collection('tournaments').doc('current').update({
            'roulette_state.spinning': false
          }).catch(e => {});
        }

        appState.isSpinning = false;
        document.getElementById('spinBtn').disabled = false;
      }, 4000);
    }

    // 最後の1人に自動でシード権を付与
    function autoAssignSeed(player) {
      appState.isSpinning = true;
      document.getElementById('spinBtn').disabled = true;

      const rotation = 1800 + Math.random() * 720;

      // Firestoreにルーレット状態を保存
      if (db) {
        db.collection('tournaments').doc('current').update({
          roulette_state: {
            spinning: true,
            rotation: rotation,
            seed_lottery: true,
            seed_player_id: player.entry_id,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          }
        }).catch(e => console.log('Seed sync error:', e));
      }

      playSpinSound();
      document.getElementById('wheelInner').style.transform = 'rotate(' + rotation + 'deg)';

      setTimeout(() => {
        // シード権を付与
        if (db) {
          db.collection('entries').doc(player.id).update({ has_seed: true }).catch(e => {});
        }
        player.has_seed = true;

        // VS表示をシード用に
        document.getElementById('vsOverlay').style.display = 'flex';
        document.getElementById('vsPlayer1Id').textContent = 'ID-' + String(player.entry_id).padStart(2, '0');
        document.getElementById('vsPlayer1Name').textContent = player.username;
        document.getElementById('vsPlayer1Icon').innerHTML = player.icon_url ? '<img src="' + player.icon_url + '" style="width:100%;height:100%;object-fit:cover;">' : '<svg class="silhouette-icon" viewBox="0 0 100 120"><circle cx="50" cy="30" r="22"/><path d="M10 120 Q10 70 50 65 Q90 70 90 120Z"/></svg>';
        document.getElementById('vsPlayer2Id').textContent = 'SEED';
        document.getElementById('vsPlayer2Name').textContent = '不戦勝';
        document.getElementById('vsPlayer2Icon').innerHTML = '<span>🎖️</span>';

        playVsSound();
        appendLog('🎖️ ' + player.username + ' がシード権を獲得！（最後の1人）');
        showToast(player.username + ' がシード権を獲得！', 'success');

        appState.isSpinning = false;
        document.getElementById('spinBtn').disabled = false;

        updateRouletteWheel();
        updateEntriesDisplay();

        // 回転完了を同期
        if (db) {
          db.collection('tournaments').doc('current').update({
            'roulette_state.spinning': false
          }).catch(e => {});
        }

        // 全対戦カード確定チェック
        checkAllMatchupsDecided();
      }, 4000);
    }
    
    // 他デバイスからのルーレット同期を処理
    function handleRouletteSync(state) {
      if (!state) return;
      
      // シード抽選の場合
      if (state.seed_lottery) {
        const seedPlayer = appState.entries.find(e => e.entry_id === state.seed_player_id);
        
        if (state.spinning && !appState.isSpinning) {
          appState.isSpinning = true;
          playSpinSound();
          document.getElementById('wheelInner').style.transform = 'rotate(' + state.rotation + 'deg)';
          
          setTimeout(() => {
            if (seedPlayer) {
              document.getElementById('vsOverlay').style.display = 'flex';
              document.getElementById('vsPlayer1Id').textContent = 'ID-' + String(seedPlayer.entry_id).padStart(2, '0');
              document.getElementById('vsPlayer1Name').textContent = seedPlayer.username;
              document.getElementById('vsPlayer1Icon').innerHTML = seedPlayer.icon_url ? '<img src="' + seedPlayer.icon_url + '" style="width:100%;height:100%;object-fit:cover;">' : '<svg class="silhouette-icon" viewBox="0 0 100 120"><circle cx="50" cy="30" r="22"/><path d="M10 120 Q10 70 50 65 Q90 70 90 120Z"/></svg>';
              document.getElementById('vsPlayer2Id').textContent = 'SEED';
              document.getElementById('vsPlayer2Name').textContent = '不戦勝';
              document.getElementById('vsPlayer2Icon').innerHTML = '<span>🎖️</span>';
              playVsSound();
            }
            appState.isSpinning = false;
          }, 4000);
        }
        return;
      }
      
      // 通常の対戦抽選の場合
      const p1 = appState.entries.find(e => e.entry_id === state.player1_id);
      const p2 = appState.entries.find(e => e.entry_id === state.player2_id);
      
      if (state.spinning && !appState.isSpinning) {
        // 他デバイスで回転開始
        appState.isSpinning = true;
        playSpinSound();
        document.getElementById('wheelInner').style.transform = 'rotate(' + state.rotation + 'deg)';
        
        setTimeout(() => {
          playVsSound();
          if (p1 && p2) {
            appState.selectedPlayer1 = p1;
            appState.selectedPlayer2 = p2;
            updateVsDisplay(p1, p2);
          }
          appState.isSpinning = false;
        }, 4000);
      } else if (!state.spinning && p1 && p2) {
        // 回転完了後の状態を同期
        appState.selectedPlayer1 = p1;
        appState.selectedPlayer2 = p2;
        updateVsDisplay(p1, p2);
      }
    }
    
    // ルーレット回転音
    function playSpinSound() {
      if (!seEnabled) return;
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const duration = 3.5;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = 'sine';
        // 周波数を上げていく
        osc.frequency.setValueAtTime(200, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + duration);
        gain.gain.setValueAtTime(seVolume * 0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + duration);
      } catch(e) { console.log('Spin sound error:', e); }
    }
    
    // ========== トーナメント表機能 ==========
    let bracketMode = false;
    let tournamentEndedLocally = false;
    let bracketResizeTimer = null;
    window.addEventListener('resize', function() {
      if (!bracketMode) return;
      clearTimeout(bracketResizeTimer);
      bracketResizeTimer = setTimeout(function() { generateBracket(); }, 200);
    });

    // トーナメント表の表示/非表示切り替え
    function toggleBracketView() {
      bracketMode = !bracketMode;
      const rouletteMain = document.querySelector('.lottery-main');
      const bracketContainer = document.getElementById('bracketContainer');
      const lotterySidebar = document.querySelector('.lottery-sidebar');
      const lotteryArena = document.getElementById('lotteryArena');
      const lotteryEntrance = document.getElementById('lotteryEntrance');
      
      if (bracketMode) {
        // トーナメント表を全画面表示
        rouletteMain.style.display = 'none';
        if (lotterySidebar) lotterySidebar.style.display = 'none';
        if (lotteryArena) lotteryArena.style.gridTemplateColumns = '1fr';
        if (lotteryEntrance) lotteryEntrance.style.display = 'none';
        bracketContainer.classList.add('active');
        generateBracket();
      } else {
        // ルーレット画面に戻す
        rouletteMain.style.display = 'flex';
        if (lotterySidebar) lotterySidebar.style.display = '';
        if (lotteryArena) lotteryArena.style.gridTemplateColumns = '';
        if (lotteryEntrance) lotteryEntrance.style.display = 'none'; // 抽選会場内では常に非表示
        bracketContainer.classList.remove('active');
        // トーナメント表ボタンを再表示
        updateBracketControls();
      }
    }
    
    // トーナメント表を生成（線で勝ち上がる形式）
    function generateBracket() {
      const container = document.getElementById('bracketContent');
      const allEntries = getGroupFilteredEntries();
      const matches = getGroupFilteredMatches();
      const isAdmin = appState.isAdmin || appState.tournament?.admin_device === appState.deviceId;

      // タイトル更新
      const bracketTitleEl = document.getElementById('bracketTitle');
      if (bracketTitleEl) {
        if (appState.activeGroup === 'finals') {
          bracketTitleEl.textContent = '🏆 決勝トーナメント';
        } else if (appState.activeGroup && appState.tournament?.group_phase) {
          bracketTitleEl.textContent = '🏆 グループ' + appState.activeGroup + ' トーナメント表';
        } else {
          bracketTitleEl.textContent = '🏆 トーナメント表';
        }
      }

      if (allEntries.length === 0) {
        container.innerHTML = '<p style="color:var(--text-dim);text-align:center;">参加者がいません</p>';
        return;
      }
      
      // ブラケットサイズを計算（2のべき乗）
      const totalPlayers = allEntries.length;
      const rounds = Math.ceil(Math.log2(Math.max(totalPlayers, 2)));
      const bracketSize = Math.pow(2, rounds);
      
      // 1回戦のスロット配置（ルーレット結果の対戦ペアとシード権を反映）
      const bracketSlots = new Array(bracketSize).fill(null);
      const placedIds = new Set();
      let slotIdx = 0;

      // matchesはcreated_at昇順。各プレイヤーの初回試合ペアを隣接スロットに配置
      matches.forEach(m => {
        if (placedIds.has(m.player1_id) || placedIds.has(m.player2_id)) return;
        const p1 = allEntries.find(e => e.entry_id === m.player1_id);
        const p2 = allEntries.find(e => e.entry_id === m.player2_id);
        if (p1 && p2 && slotIdx + 1 < bracketSize) {
          bracketSlots[slotIdx] = p1;
          bracketSlots[slotIdx + 1] = p2;
          placedIds.add(p1.entry_id);
          placedIds.add(p2.entry_id);
          slotIdx += 2;
        }
      });

      // シード選手をBYEスロットの隣に配置（偶数スロットに配置、奇数スロットがBYE）
      allEntries.filter(p => p.has_seed && !placedIds.has(p.entry_id)).forEach(p => {
        if (slotIdx < bracketSize) {
          bracketSlots[slotIdx] = p;
          placedIds.add(p.entry_id);
          slotIdx += 2;
        }
      });

      // 残りの未配置プレイヤー（通常はないが安全策）
      allEntries.filter(p => !placedIds.has(p.entry_id)).forEach(p => {
        for (let i = 0; i < bracketSize; i++) {
          if (!bracketSlots[i]) {
            bracketSlots[i] = p;
            break;
          }
        }
      });
      
      // 優勝者
      const activeEntries = allEntries.filter(e => e.status !== 'LOST');
      const champion = activeEntries.length === 1 ? activeEntries[0] : null;
      
      // 各ラウンドの勝者を追跡
      const roundWinners = [];
      for (let r = 0; r < rounds; r++) {
        roundWinners.push([]);
      }
      
      // 勝者を追跡するための情報を構築
      const playerProgress = {}; // entry_id -> { rounds: [true/false for each round] }
      allEntries.forEach(p => {
        playerProgress[p.entry_id] = { rounds: [], slotIndex: bracketSlots.indexOf(p) };
      });
      
      // 各ラウンドの勝者を特定
      for (let r = 0; r < rounds; r++) {
        const matchesInRound = Math.pow(2, rounds - 1 - r);

        for (let m = 0; m < matchesInRound; m++) {
          let player1 = null, player2 = null;

          if (r === 0) {
            player1 = bracketSlots[m * 2] || null;
            player2 = bracketSlots[m * 2 + 1] || null;

            // BYE処理：片方がnullならもう片方が自動勝利（シード自動進出）
            if (player1 && !player2) {
              roundWinners[r].push({
                matchIndex: m,
                winnerId: player1.entry_id,
                player1: player1,
                player2: null,
                isBye: true
              });
              if (playerProgress[player1.entry_id]) {
                playerProgress[player1.entry_id].rounds[r] = true;
              }
              continue;
            }
            if (!player1 && player2) {
              roundWinners[r].push({
                matchIndex: m,
                winnerId: player2.entry_id,
                player1: null,
                player2: player2,
                isBye: true
              });
              if (playerProgress[player2.entry_id]) {
                playerProgress[player2.entry_id].rounds[r] = true;
              }
              continue;
            }
          } else {
            const rangeSize = Math.pow(2, r + 1);
            const range1Start = m * rangeSize;
            const range2Start = m * rangeSize + rangeSize / 2;

            // 前ラウンドで勝利した人を探す（BYE勝利含む）
            const prevRoundWinnersLeft = roundWinners[r - 1].filter(w => {
              const gs = w.matchIndex * Math.pow(2, r);
              return gs >= range1Start && gs < range1Start + rangeSize / 2;
            });
            const prevRoundWinnersRight = roundWinners[r - 1].filter(w => {
              const gs = w.matchIndex * Math.pow(2, r);
              return gs >= range2Start && gs < range2Start + rangeSize / 2;
            });

            if (prevRoundWinnersLeft.length > 0) {
              const wId = prevRoundWinnersLeft[prevRoundWinnersLeft.length - 1].winnerId;
              player1 = allEntries.find(e => e.entry_id === wId) || null;
            } else {
              for (let i = range1Start; i < range1Start + rangeSize / 2 && i < bracketSlots.length; i++) {
                if (bracketSlots[i] && bracketSlots[i].status !== 'LOST') {
                  player1 = bracketSlots[i];
                  break;
                }
              }
            }
            if (prevRoundWinnersRight.length > 0) {
              const wId = prevRoundWinnersRight[prevRoundWinnersRight.length - 1].winnerId;
              player2 = allEntries.find(e => e.entry_id === wId) || null;
            } else {
              for (let i = range2Start; i < range2Start + rangeSize / 2 && i < bracketSlots.length; i++) {
                if (bracketSlots[i] && bracketSlots[i].status !== 'LOST') {
                  player2 = bracketSlots[i];
                  break;
                }
              }
            }

            // 上位ラウンドのBYE処理：片方が不在なら自動進出
            if (player1 && !player2) {
              roundWinners[r].push({
                matchIndex: m, winnerId: player1.entry_id,
                player1: player1, player2: null, isBye: true
              });
              if (playerProgress[player1.entry_id]) playerProgress[player1.entry_id].rounds[r] = true;
              continue;
            }
            if (!player1 && player2) {
              roundWinners[r].push({
                matchIndex: m, winnerId: player2.entry_id,
                player1: null, player2: player2, isBye: true
              });
              if (playerProgress[player2.entry_id]) playerProgress[player2.entry_id].rounds[r] = true;
              continue;
            }
            if (!player1 && !player2) continue;
          }

          const registeredMatch = matches.find(match =>
            (match.player1_id === player1?.entry_id && match.player2_id === player2?.entry_id) ||
            (match.player2_id === player1?.entry_id && match.player1_id === player2?.entry_id)
          );

          if (registeredMatch?.winner_id) {
            roundWinners[r].push({
              matchIndex: m,
              winnerId: registeredMatch.winner_id,
              player1: player1,
              player2: player2
            });

            if (playerProgress[registeredMatch.winner_id]) {
              playerProgress[registeredMatch.winner_id].rounds[r] = true;
            }
          }
        }
      }
      
      // 画面幅を取得（ブラケットコンテナの利用可能幅）
      const containerEl = document.getElementById('bracketContainer');
      const availableWidth = (containerEl ? containerEl.clientWidth : window.innerWidth) - 32; // padding分を引く

      // デスクトップ基準のサイズ（人数に応じて）
      let baseBoxW, baseBoxH, baseGap, baseRoundH;
      if (bracketSize <= 2) {
        baseBoxW = 100; baseBoxH = 140; baseGap = 50; baseRoundH = 130;
      } else if (bracketSize <= 4) {
        baseBoxW = 80; baseBoxH = 120; baseGap = 30; baseRoundH = 120;
      } else if (bracketSize <= 8) {
        baseBoxW = 70; baseBoxH = 110; baseGap = 20; baseRoundH = 110;
      } else if (bracketSize <= 16) {
        baseBoxW = 60; baseBoxH = 100; baseGap = 15; baseRoundH = 100;
      } else {
        baseBoxW = 50; baseBoxH = 90; baseGap = 10; baseRoundH = 70;
      }

      // デスクトップ基準幅と画面幅を比較して縮小率を計算
      const desktopWidth = bracketSize * (baseBoxW + baseGap);
      const scale = Math.min(1, availableWidth / desktopWidth);

      // 最小サイズの下限を設定（読めないほど小さくならないように）
      const boxWidth = Math.max(28, Math.round(baseBoxW * scale));
      const boxHeight = Math.max(50, Math.round(baseBoxH * scale));
      const boxGap = Math.max(4, Math.round(baseGap * scale));
      const roundHeight = Math.max(40, Math.round(baseRoundH * scale));

      const svgWidth = bracketSize * (boxWidth + boxGap);
      const lineAreaHeight = rounds * roundHeight + 30;

      // ヘルパー: スロットiのX中心座標
      function slotXPos(idx) { return idx * (boxWidth + boxGap) + boxWidth / 2; }
      // ヘルパー: スロット範囲の中心X座標
      function groupCenterX(start, end) { return (slotXPos(start) + slotXPos(end)) / 2; }

      // HTMLを生成
      const needsScroll = svgWidth > availableWidth;
      let html = '';
      if (needsScroll) {
        html += '<div class="bracket-scroll-hint" style="display:block;">← スワイプでスクロール →</div>';
      }
      html += '<div class="bracket-tree" style="display:flex;flex-direction:column;align-items:center;">';

      // 優勝枠サイズ（人数とスケールに応じて拡縮）
      const champScale = Math.max(0.6, scale);
      const champPadV = Math.max(0.4, 0.8 * champScale);
      const champPadH = Math.max(0.6, 1.5 * champScale);
      const champPad = champPadV + 'rem ' + champPadH + 'rem';
      const champTrophy = Math.max(1, (bracketSize <= 4 ? 2 : 1.5) * champScale) + 'rem';
      const champNameSize = Math.max(0.7, (bracketSize <= 4 ? 1.2 : 1) * champScale) + 'rem';

      // 優勝枠（最上部）
      html += `
        <div class="bracket-champion-box ${champion ? '' : 'empty'}" style="padding:${champPad};">
          <div class="champion-trophy" style="font-size:${champTrophy};">🏆</div>
          <div class="champion-label">優勝</div>
          <div class="champion-name" style="writing-mode:horizontal-tb;text-orientation:mixed;font-size:${champNameSize};">${champion ? escapeHtml(champion.username) : '???'}</div>
        </div>
      `;

      // SVGとプレイヤーを含むコンテナ
      html += `<div style="position:relative;width:${svgWidth}px;height:${lineAreaHeight + boxHeight}px;">`;

      // SVGの線幅もスケール
      const strokeW = Math.max(1, Math.round(2 * Math.max(0.5, scale)));
      const strokeWWin = Math.max(1.5, Math.round(3 * Math.max(0.5, scale)));

      // SVG線エリア（プレイヤーボックスと重ならない高さ）
      html += `<svg class="bracket-lines" width="${svgWidth}" height="${lineAreaHeight}" style="position:absolute;top:0;left:0;" overflow="hidden">`;

      // === パス1: 全トーナメント経路の骨格線（薄い緑） ===
      for (let r = 0; r < rounds; r++) {
        const numMatches = Math.pow(2, rounds - 1 - r);
        for (let m = 0; m < numMatches; m++) {
          const groupSize = Math.pow(2, r + 1);
          const halfSize = Math.pow(2, r);
          const groupStart = m * groupSize;

          let leftX, rightX;
          if (r === 0) {
            leftX = slotXPos(groupStart);
            rightX = slotXPos(groupStart + 1);
          } else {
            leftX = groupCenterX(groupStart, groupStart + halfSize - 1);
            rightX = groupCenterX(groupStart + halfSize, groupStart + groupSize - 1);
          }

          const bottomY = lineAreaHeight - r * roundHeight;
          const topY = lineAreaHeight - (r + 1) * roundHeight;

          // 左側垂直線
          html += `<line x1="${leftX}" y1="${bottomY}" x2="${leftX}" y2="${topY}" class="bracket-line" style="stroke-width:${strokeW};" />`;
          // 右側垂直線
          html += `<line x1="${rightX}" y1="${bottomY}" x2="${rightX}" y2="${topY}" class="bracket-line" style="stroke-width:${strokeW};" />`;
          // 上部水平線
          html += `<line x1="${leftX}" y1="${topY}" x2="${rightX}" y2="${topY}" class="bracket-line" style="stroke-width:${strokeW};" />`;
        }
      }

      // 決勝→優勝への中央線（骨格）
      const finalHalf = Math.pow(2, rounds - 1);
      const finalLeftX = rounds === 1 ? slotXPos(0) : groupCenterX(0, finalHalf - 1);
      const finalRightX = rounds === 1 ? slotXPos(1) : groupCenterX(finalHalf, bracketSize - 1);
      const finalCenterX = (finalLeftX + finalRightX) / 2;
      const finalTopY = lineAreaHeight - rounds * roundHeight;
      html += `<line x1="${finalCenterX}" y1="${finalTopY}" x2="${finalCenterX}" y2="0" class="bracket-line" style="stroke-width:${strokeW};" />`;

      // === パス2: 勝者の経路（明るい緑で発光） ===
      for (let r = 0; r < rounds; r++) {
        const numMatches = Math.pow(2, rounds - 1 - r);
        for (let m = 0; m < numMatches; m++) {
          const rw = roundWinners[r].find(w => w.matchIndex === m);
          if (!rw) continue;

          const groupSize = Math.pow(2, r + 1);
          const halfSize = Math.pow(2, r);
          const groupStart = m * groupSize;

          let leftX, rightX;
          if (r === 0) {
            leftX = slotXPos(groupStart);
            rightX = slotXPos(groupStart + 1);
          } else {
            leftX = groupCenterX(groupStart, groupStart + halfSize - 1);
            rightX = groupCenterX(groupStart + halfSize, groupStart + groupSize - 1);
          }

          const bottomY = lineAreaHeight - r * roundHeight;
          const topY = lineAreaHeight - (r + 1) * roundHeight;
          const centerX = (leftX + rightX) / 2;

          // 勝者がどちら側か判定
          const winnerSlotIdx = bracketSlots.findIndex(s => s && s.entry_id === rw.winnerId);
          const isLeftWinner = winnerSlotIdx >= groupStart && winnerSlotIdx < groupStart + halfSize;
          const winnerX = isLeftWinner ? leftX : rightX;

          // 勝者の垂直線（明るい緑）
          html += `<line x1="${winnerX}" y1="${bottomY}" x2="${winnerX}" y2="${topY}" class="bracket-line winner" style="stroke-width:${strokeWWin};" />`;
          // 勝者から中央への水平線（明るい緑）
          html += `<line x1="${winnerX}" y1="${topY}" x2="${centerX}" y2="${topY}" class="bracket-line winner" style="stroke-width:${strokeWWin};" />`;
        }
      }

      // 優勝者の決勝→優勝線（明るい緑）
      if (champion) {
        html += `<line x1="${finalCenterX}" y1="${finalTopY}" x2="${finalCenterX}" y2="0" class="bracket-line winner" style="stroke-width:${strokeWWin};" />`;
      }

      html += '</svg>';

      // プレイヤーボックスのフォントサイズ（スケールに応じて縮小）
      const baseNameSize = bracketSize <= 2 ? 1 : (bracketSize <= 4 ? 0.9 : 0.8);
      const baseIdSize = bracketSize <= 4 ? 0.7 : 0.6;
      const nameFontSize = Math.max(0.5, baseNameSize * Math.max(0.65, scale)) + 'rem';
      const idFontSize = Math.max(0.4, baseIdSize * Math.max(0.65, scale)) + 'rem';
      const nameMaxH = Math.max(30, Math.round(80 * scale));
      const boxPad = Math.max(2, Math.round(8 * scale));
      const boxStyle = `width:${boxWidth}px;min-height:${boxHeight}px;padding:${boxPad}px ${Math.max(2, Math.round(4 * scale))}px;`;

      // プレイヤーボックス（SVGの直下、重ならない位置に配置）
      html += `<div class="bracket-round-row" style="position:absolute;top:${lineAreaHeight}px;left:0;right:0;display:flex;justify-content:center;gap:${boxGap}px;">`;

      for (let i = 0; i < bracketSize; i++) {
        const player = bracketSlots[i];

        if (!player) {
          // BYEスロットは非表示（スペースのみ確保）
          html += `<div style="${boxStyle};visibility:hidden;"></div>`;
          continue;
        }

        // 対戦相手を特定
        const pairIndex = (i % 2 === 0) ? i + 1 : i - 1;
        const opponent = bracketSlots[pairIndex] || null;
        const isByeWin = !opponent;

        // 1回戦の試合を検索
        const match = !isByeWin ? matches.find(mt =>
          (mt.player1_id === player.entry_id && mt.player2_id === opponent.entry_id) ||
          (mt.player2_id === player.entry_id && mt.player1_id === opponent.entry_id)
        ) : null;

        const winnerId = match?.winner_id;
        const isPending = match && !winnerId;
        const isWinner = isByeWin || winnerId === player.entry_id;
        const isLoser = !isByeWin && winnerId && winnerId !== player.entry_id;
        const hasSeed = player.has_seed;
        const canClick = isAdmin && isPending && opponent;

        const classes = [
          'bracket-player-box',
          isWinner ? 'winner' : '',
          isLoser ? 'loser' : '',
          hasSeed ? 'seed' : '',
          canClick ? 'clickable' : '',
          isPending ? 'active' : ''
        ].filter(Boolean).join(' ');

        html += `
          <div class="${classes}" style="${boxStyle}" data-slot="${i}"
            ${canClick ? `onclick="selectBracketWinner(${player.entry_id}, ${opponent.entry_id}, '${escapeHtml(player.username)}', '${escapeHtml(opponent.username)}')"` : ''}>
            ${isWinner && !isByeWin ? '<span class="winner-mark">🏆</span>' : ''}
            ${hasSeed ? '<span class="seed-mark">🎖️</span>' : ''}
            <span class="player-name-v" style="font-size:${nameFontSize};max-height:${nameMaxH}px;">${escapeHtml(player.username)}</span>
            <span class="player-id-v" style="font-size:${idFontSize};">${String(player.entry_id).padStart(2, '0')}</span>
          </div>
        `;
      }

      html += '</div>'; // bracket-round-row

      // === 上位ラウンドのマッチ自動作成 + ジャンクションにVSボタン表示 ===
      const vsBtnSize = Math.max(24, Math.round(30 * Math.max(0.6, scale)));

      for (let r = 1; r < rounds; r++) {
        const numMatchesInRound = Math.pow(2, rounds - 1 - r);
        for (let m = 0; m < numMatchesInRound; m++) {
          const groupSize = Math.pow(2, r + 1);
          const halfSize = Math.pow(2, r);
          const groupStart = m * groupSize;

          let p1 = null, p2 = null;
          const prevWL = roundWinners[r - 1].filter(w => {
            const gs = w.matchIndex * Math.pow(2, r);
            return gs >= groupStart && gs < groupStart + halfSize;
          });
          const prevWR = roundWinners[r - 1].filter(w => {
            const gs = w.matchIndex * Math.pow(2, r);
            return gs >= groupStart + halfSize && gs < groupStart + groupSize;
          });
          if (prevWL.length > 0) p1 = allEntries.find(e => e.entry_id === prevWL[prevWL.length - 1].winnerId);
          if (prevWR.length > 0) p2 = allEntries.find(e => e.entry_id === prevWR[prevWR.length - 1].winnerId);

          if (!p1 && !p2) continue;

          const rw = roundWinners[r].find(w => w.matchIndex === m);
          if (rw && rw.isBye) continue;
          const winnerId = rw ? rw.winnerId : null;

          // 両者揃った場合のマッチ作成・VSボタン表示
          if (p1 && p2) {
            const matchRecord = matches.find(mt =>
              (mt.player1_id === p1.entry_id && mt.player2_id === p2.entry_id) ||
              (mt.player2_id === p1.entry_id && mt.player1_id === p2.entry_id)
            );
            const needsMatch = !matchRecord && !winnerId;

            // 管理者なら未作成のマッチを自動作成
            if (needsMatch && isAdmin && db) {
              const key = p1.entry_id + '_' + p2.entry_id + '_r' + r;
              if (!window._bracketMatchCreating) window._bracketMatchCreating = {};
              if (!window._bracketMatchCreating[key]) {
                window._bracketMatchCreating[key] = true;
                db.collection('matches').add({
                  player1_id: p1.entry_id,
                  player1_name: p1.username,
                  player2_id: p2.entry_id,
                  player2_name: p2.username,
                  winner_id: null,
                  round: r + 1,
                  group: appState.activeGroup || null,
                  created_at: firebase.firestore.FieldValue.serverTimestamp()
                }).then(() => { delete window._bracketMatchCreating[key]; })
                  .catch(e => { delete window._bracketMatchCreating[key]; });
              }
            }

            // 水平線の中央にVSボタンを配置（勝者未決定時のみ・管理者のみ）
            const leftX = groupCenterX(groupStart, groupStart + halfSize - 1);
            const rightX = groupCenterX(groupStart + halfSize, groupStart + groupSize - 1);
            const centerX = (leftX + rightX) / 2;
            const junctionY = lineAreaHeight - (r + 1) * roundHeight;
            const isPending = (matchRecord && !matchRecord.winner_id) || needsMatch;

            if (isPending && isAdmin) {
              html += `<div class="bracket-vs-btn" style="position:absolute;left:${centerX - vsBtnSize / 2}px;top:${junctionY - vsBtnSize / 2}px;width:${vsBtnSize}px;height:${vsBtnSize}px;cursor:pointer;z-index:5;"
                onclick="showUpperRoundMatch(${p1.entry_id}, '${escapeHtml(p1.username)}', ${p2.entry_id}, '${escapeHtml(p2.username)}')">
                <span style="font-size:${Math.max(0.6, 0.8 * scale)}rem;">VS</span>
              </div>`;
            }
          }
        }
      }

      html += '</div>'; // SVGとプレイヤーのコンテナ
      html += '</div>'; // bracket-tree

      container.innerHTML = html;
      
      // 管理者用終了ボタンの表示制御
      const bracketEndBtn = document.getElementById('bracketEndBtn');
      if (bracketEndBtn) {
        if (isAdmin) {
          bracketEndBtn.style.display = '';
        } else {
          bracketEndBtn.style.display = 'none';
        }
      }
    }
    
    // ブラケットプレイヤーをレンダリング
    function renderBracketPlayer(player, opponent, winnerId, isPending, isAdmin, side) {
      if (!player) {
        return `<div class="bracket-player-box empty ${side}"><span class="player-name-v">BYE</span></div>`;
      }
      
      const isWinner = winnerId === player.entry_id;
      const isLoser = winnerId && winnerId !== player.entry_id;
      const hasSeed = player.has_seed;
      const canClick = isAdmin && isPending && opponent;
      
      const classes = [
        'bracket-player-box',
        side,
        isWinner ? 'winner' : '',
        isLoser ? 'loser' : '',
        hasSeed ? 'seed' : '',
        canClick ? 'clickable' : '',
        isPending ? 'active' : ''
      ].filter(Boolean).join(' ');
      
      return `
        <div class="${classes}"
          ${canClick ? `onclick="selectBracketWinner(${player.entry_id}, ${opponent.entry_id}, '${escapeHtml(player.username)}', '${escapeHtml(opponent.username)}')"` : ''}>
          ${isWinner ? '<span class="winner-mark">🏆</span>' : ''}
          ${hasSeed ? '<span class="seed-mark">🎖️</span>' : ''}
          <span class="player-name-v">${escapeHtml(player.username)}</span>
          <span class="player-id-v">${String(player.entry_id).padStart(2, '0')}</span>
        </div>
      `;
    }
    
    // 旧関数（互換性のため）
    function renderSlotVertical(player, opponent, winnerId, isPending, isAdmin) {
      return renderBracketPlayer(player, opponent, winnerId, isPending, isAdmin, 'left');
    }
    function renderSlot(player, opponent, winnerId, isPending, isAdmin, position, isByeMatch = false) {
      return renderBracketPlayer(player, opponent, winnerId, isPending, isAdmin, 'left');
    }
    
    // 試合のHTMLを生成
    function generateMatchHtml(match, p1, p2, canDecide) {
      const isAdmin = appState.isAdmin || appState.tournament?.admin_device === appState.deviceId;
      const isWinner1 = match.winner_id === p1?.entry_id;
      const isWinner2 = match.winner_id === p2?.entry_id;
      const hasWinner = !!match.winner_id;
      
      const clickable = canDecide && isAdmin && !hasWinner;
      
      let html = `<div class="bracket-match${canDecide ? ' deciding' : ''}">`;
      
      if (p1) {
        const statusLabel = isWinner1 ? '<span style="color:var(--hud-gold);font-size:0.75rem;margin-left:auto;">🏆 勝者</span>' : (hasWinner ? '<span style="color:#666;font-size:0.75rem;margin-left:auto;">敗退</span>' : '');
        html += `<div class="bracket-player ${isWinner1 ? 'winner' : (hasWinner ? 'loser' : '')} ${clickable ? 'clickable' : ''}" 
          ${clickable ? `onclick="selectBracketWinner(${match.player1_id}, ${match.player2_id}, '${escapeHtml(p1.username)}', '${escapeHtml(p2?.username || '')}')"` : ''}>
          <span class="bracket-player-id">ID-${String(p1.entry_id).padStart(2,'0')}</span>
          <span class="bracket-player-name">${escapeHtml(p1.username)}</span>
          ${statusLabel}
        </div>`;
      }
      
      if (p2) {
        const statusLabel = isWinner2 ? '<span style="color:var(--hud-gold);font-size:0.75rem;margin-left:auto;">🏆 勝者</span>' : (hasWinner ? '<span style="color:#666;font-size:0.75rem;margin-left:auto;">敗退</span>' : '');
        html += `<div class="bracket-player ${isWinner2 ? 'winner' : (hasWinner ? 'loser' : '')} ${clickable ? 'clickable' : ''}"
          ${clickable ? `onclick="selectBracketWinner(${match.player2_id}, ${match.player1_id}, '${escapeHtml(p2.username)}', '${escapeHtml(p1?.username || '')}')"` : ''}>
          <span class="bracket-player-id">ID-${String(p2.entry_id).padStart(2,'0')}</span>
          <span class="bracket-player-name">${escapeHtml(p2.username)}</span>
          ${statusLabel}
        </div>`;
      }
      
      html += '</div>';
      return html;
    }
    
    // 上位ラウンドの対戦：VSボタンクリック時に勝者選択モーダルを表示
    function showUpperRoundMatch(p1Id, p1Name, p2Id, p2Name) {
      const isAdmin = appState.isAdmin || appState.tournament?.admin_device === appState.deviceId;
      if (!isAdmin) return;

      // upperRoundPickerモーダルを動的生成して表示
      let picker = document.getElementById('upperRoundPicker');
      if (!picker) {
        picker = document.createElement('div');
        picker.className = 'modal-overlay';
        picker.id = 'upperRoundPicker';
        document.body.appendChild(picker);
      }
      picker.innerHTML = `
        <div class="modal-content" style="max-width:360px;">
          <button class="modal-close-btn" onclick="hideModal('upperRoundPicker')">×</button>
          <h3 class="modal-title" style="color:var(--hud-gold);">勝者を選択</h3>
          <p style="text-align:center;color:var(--text-dim);margin:0.5rem 0;font-size:0.85rem;">クリックで勝者を確定します</p>
          <div style="display:flex;gap:0.8rem;justify-content:center;margin:1rem 0;">
            <button class="modal-btn" style="background:var(--hud-green);border-color:var(--hud-green);padding:0.7rem 1.2rem;font-size:1rem;cursor:pointer;flex:1;"
              onclick="hideModal('upperRoundPicker');selectBracketWinner(${p1Id}, ${p2Id}, '${p1Name.replace(/'/g, "\\'")}', '${p2Name.replace(/'/g, "\\'")}')">
              ${p1Name}
            </button>
            <span style="color:var(--hud-gold);font-size:1.3rem;align-self:center;font-weight:bold;">VS</span>
            <button class="modal-btn" style="background:var(--hud-green);border-color:var(--hud-green);padding:0.7rem 1.2rem;font-size:1rem;cursor:pointer;flex:1;"
              onclick="hideModal('upperRoundPicker');selectBracketWinner(${p2Id}, ${p1Id}, '${p2Name.replace(/'/g, "\\'")}', '${p1Name.replace(/'/g, "\\'")}')">
              ${p2Name}
            </button>
          </div>
          <div class="modal-buttons">
            <button class="modal-btn modal-btn-cancel" onclick="hideModal('upperRoundPicker')">キャンセル</button>
          </div>
        </div>`;
      showModal('upperRoundPicker');
    }

    // トーナメント表から勝者を選択
    function selectBracketWinner(winnerId, loserId, winnerName, loserName) {
      // 管理者のみ操作可能
      const isAdmin = appState.isAdmin || appState.tournament?.admin_device === appState.deviceId;
      if (!isAdmin) {
        return; // 何も反応しない
      }

      const winner = appState.entries.find(e => e.entry_id === winnerId);
      const loser = appState.entries.find(e => e.entry_id === loserId);

      if (!winner || !loser) {
        showToast('プレイヤーが見つかりません', 'error');
        return;
      }

      // ルーレット選択をクリア（executeWinnerでブラケット用の検索を使うため）
      appState.selectedPlayer1 = null;
      appState.selectedPlayer2 = null;

      appState.pendingWinner = { winner, loser };
      document.getElementById('confirmWinnerText').textContent = winnerName + ' を勝者にしますか？';
      showModal('confirmWinnerModal');
    }
    
    // トーナメント表ボタンの表示制御
    function updateBracketControls() {
      const controls = document.getElementById('bracketControls');
      if (!controls) return;

      const filteredEntries = getGroupFilteredEntries();
      const activeCount = filteredEntries.filter(e => e.status !== 'LOST').length;
      const matchCount = getGroupFilteredMatches().length;

      // 条件：対戦が1つ以上確定している、かつ21名以下
      if (matchCount >= 1 && activeCount <= 21 && activeCount >= 1) {
        controls.style.display = 'flex';
      } else {
        controls.style.display = 'none';
      }
    }

    // 全対戦カードが確定したかチェックし、確定済みならトーナメント表を表示
    function checkAllMatchupsDecided() {
      // ブラケット表示中は自動マッチメイクしない（ブラケットが進行を管理）
      if (bracketMode) return;

      const active = getGroupFilteredEntries().filter(e => e.status !== 'LOST');
      const inMatch = getGroupFilteredMatches().filter(m => !m.winner_id);
      const inMatchIds = inMatch.flatMap(m => [m.player1_id, m.player2_id]);
      const unmatched = active.filter(e => !inMatchIds.includes(e.entry_id) && !e.has_seed);

      // 未マッチの人が1人→自動シード付与
      // （現フェーズ内でまだ勝利していない選手のみ。統合フェーズでは統合後のマッチのみチェック）
      if (unmatched.length === 1) {
        const player = unmatched[0];
        const currentPhaseMatches = getGroupFilteredMatches();
        const hasWonInPhase = currentPhaseMatches.some(m => m.winner_id === player.entry_id);
        if (!hasWonInPhase) {
          autoAssignSeed(unmatched[0]);
          return;
        }
      }

      // 全員がマッチ済みまたはシード済み → トーナメント表ボタンを表示
      if (unmatched.length === 0 && getGroupFilteredMatches().length > 0) {
        updateBracketControls();
        if (!bracketMode) {
          const groupLabel = appState.activeGroup && appState.activeGroup !== 'finals' ? 'グループ' + appState.activeGroup + 'の' : '';
          showToast(groupLabel + '全対戦カードが確定しました！', 'success');
        }
      }
    }
    
    
    
    // 勝者選択を有効化
    function enableWinnerSelection() {
      const p1Box = document.getElementById('vsPlayer1Box');
      const p2Box = document.getElementById('vsPlayer2Box');
      const helpText = document.getElementById('vsHelp');
      if (p1Box) p1Box.classList.add('clickable');
      if (p2Box) p2Box.classList.add('clickable');
      if (helpText) helpText.style.display = 'block';
    }
    
    // 勝者選択を無効化
    function disableWinnerSelection() {
      const p1Box = document.getElementById('vsPlayer1Box');
      const p2Box = document.getElementById('vsPlayer2Box');
      const helpText = document.getElementById('vsHelp');
      if (p1Box) { p1Box.classList.remove('clickable'); p1Box.classList.remove('winner-selected'); }
      if (p2Box) { p2Box.classList.remove('clickable'); p2Box.classList.remove('winner-selected'); }
      if (helpText) helpText.style.display = 'none';
    }
    
    // 対戦カードから勝者を選択
    function selectWinnerFromCard(playerNum) {
      const isAdmin = appState.isAdmin || appState.tournament?.admin_device === appState.deviceId;
      if (!isAdmin) return;
      
      const p1Box = document.getElementById('vsPlayer1Box');
      const p2Box = document.getElementById('vsPlayer2Box');
      
      // クリック可能でない場合は何もしない
      if (!p1Box.classList.contains('clickable')) return;
      
      // 選択状態を表示
      if (playerNum === 1) {
        p1Box.classList.add('winner-selected');
        p2Box.classList.remove('winner-selected');
      } else {
        p2Box.classList.add('winner-selected');
        p1Box.classList.remove('winner-selected');
      }
      
      // declareWinnerを呼び出す
      declareWinner(playerNum);
    }
    
    function declareWinner(n) { appState.pendingWinner = { winner: n === 1 ? appState.selectedPlayer1 : appState.selectedPlayer2, loser: n === 1 ? appState.selectedPlayer2 : appState.selectedPlayer1 }; document.getElementById('confirmWinnerText').textContent = appState.pendingWinner.winner.username; showModal('confirmWinnerModal'); }
    async function executeWinner() { 
      if (!db) return; 
      
      // 管理者クールダウンチェック
      const cd = await checkCooldown('admin');
      if (cd.blocked) { hideModal('confirmWinnerModal'); showToast('短時間で登録・解除を繰り返したため、しばらくお待ちください（残り' + cd.remaining + '分）', 'error'); return; }
      
      const { winner, loser } = appState.pendingWinner; 
      playClick(); 
      appendLog(winner.username + 'が勝利（' + loser.username + '敗退）'); 
      
      // マッチを探す（ルーレット経由 or トーナメント表経由）
      let m = null;
      if (appState.selectedPlayer1 && appState.selectedPlayer2) {
        m = appState.matches.find(x => x.player1_id === appState.selectedPlayer1.entry_id && x.player2_id === appState.selectedPlayer2.entry_id && !x.winner_id);
      } else {
        // トーナメント表から選んだ場合
        m = appState.matches.find(x => ((x.player1_id === winner.entry_id && x.player2_id === loser.entry_id) || (x.player1_id === loser.entry_id && x.player2_id === winner.entry_id)) && !x.winner_id);
      }
      
      if (m) db.collection('matches').doc(m.id).update({ winner_id: winner.entry_id, winner_name: winner.username }); 
      const le = appState.entries.find(e => e.entry_id === loser.entry_id); 
      if (le) db.collection('entries').doc(le.id).update({ status: 'LOST' }); 
      
      hideModal('confirmWinnerModal');
      disableWinnerSelection(); // 勝者選択を無効化
      appState.selectedPlayer1 = null;
      appState.selectedPlayer2 = null;
      updateVsDisplay(null, null);
      document.getElementById('wheelInner').style.transform = 'rotate(0deg)';
      showToast('勝者を確定しました', 'success');
      checkAndUpdateStatus();
      updateBracketControls(); // トーナメント表ボタンを再表示

      // トーナメント表を更新
      if (bracketMode) generateBracket();

      // グループ勝者チェック
      checkGroupWinner(winner, loser);
    }

    // グループ統合チェック（全グループ合計の生存者が21人以下になったら統合）
    function checkGroupWinner(winner, loser) {
      if (!db) return;
      const phase = appState.tournament?.group_phase;
      if (!phase || phase === 'none' || phase === 'merged') return;

      const currentGroup = appState.activeGroup;
      if (!currentGroup || currentGroup === 'finals') return;

      // 敗者がまだ entries に反映されていない可能性があるので、loser を手動で除外
      const allActive = appState.entries.filter(e => e.status !== 'LOST' && e.entry_id !== loser.entry_id);

      // 全グループ合計の生存者が21人以下 → グループ統合
      if (allActive.length <= 21) {
        // 全エントリーのgroup・has_seedをクリア（統合・シードリセット）
        const batch = db.batch();
        appState.entries.forEach(e => {
          batch.update(db.collection('entries').doc(e.id), { group: null, has_seed: false });
        });
        batch.update(db.collection('tournaments').doc('current'), {
          group_phase: 'merged',
          active_group: null,
          groups_assigned: false
        });
        batch.commit().then(() => {
          appState.activeGroup = null;
          appState.groupPhase = 'merged';
          appState.entries.forEach(e => { e.group = null; e.has_seed = false; });
          renderGroupTabs();
          updateEntriesDisplay();
          updateRouletteWheel();
          updateBracketControls();
          showToast('全グループ統合！残り' + allActive.length + '名で最終ルーレットへ', 'success');
          appendLog('グループ統合: 残り' + allActive.length + '名 → 最終ルーレット');
        });
        return;
      }

      // まだ21人超 → グループ内の残り人数表示のみ更新
      const groupEntries = appState.entries.filter(e => e.group === currentGroup);
      const activeInGroup = groupEntries.filter(e => e.status !== 'LOST' && e.entry_id !== loser.entry_id);
      renderGroupTabs();
      updateEntriesDisplay();
      updateRouletteWheel();
    }

    // 大会終了確認
    function confirmEndTournament() {
      const select = document.getElementById('championSelect');
      const desc = document.getElementById('endTournamentDesc');
      const selectGroup = document.getElementById('championSelectGroup');
      const active = appState.entries.filter(e => e.status !== 'LOST');

      if (active.length === 1) {
        // 優勝者が確定済み（1人だけ残っている）
        const champ = active[0];
        desc.textContent = '優勝者: ' + champ.username + ' の記録を保存します';
        select.innerHTML = '';
        const opt = document.createElement('option');
        opt.value = champ.entry_id;
        opt.textContent = champ.username + ' (ID-' + String(champ.entry_id).padStart(2,'0') + ')';
        select.appendChild(opt);
        select.value = champ.entry_id;
        selectGroup.style.display = 'none';
      } else {
        // 複数残っている場合は選択式
        desc.textContent = '優勝者を選択して記録を保存します';
        selectGroup.style.display = '';
        select.innerHTML = '<option value="">-- 選択してください --</option>';
        active.forEach(e => {
          const opt = document.createElement('option');
          opt.value = e.entry_id;
          opt.textContent = e.username + ' (ID-' + String(e.entry_id).padStart(2,'0') + ')';
          select.appendChild(opt);
        });
      }
      showModal('endTournamentModal');
    }

    // 大会終了実行
    function executeEndTournament() {
      const select = document.getElementById('championSelect');
      const championId = select.value;
      if (!championId) {
        showToast('優勝者を選択してください', 'error');
        return;
      }
      const champion = appState.entries.find(e => e.entry_id === parseInt(championId));
      if (!champion) {
        showToast('優勝者が見つかりません', 'error');
        return;
      }
      playClick();
      appendLog('🏆 ' + champion.username + 'が優勝！大会終了');
      tournamentEndedLocally = true;

      // CSV用に現在のデータをキャプチャ
      const csvData = {
        gameName: appState.tournament?.game_name || '不明',
        adminName: appState.tournament?.admin_name || '不明',
        championName: champion.username,
        entries: appState.entries.map(e => ({ entry_id: e.entry_id, username: e.username }))
      };

      // 履歴に保存してから全データをクリア
      if (db) {
        db.collection('history').add({
          game_name: appState.tournament?.game_name || '不明',
          admin_name: appState.tournament?.admin_name || '不明',
          champion_name: champion.username,
          champion_id: champion.entry_id,
          total_participants: appState.entries.length,
          participants: appState.entries.map(e => ({ entry_id: e.entry_id, username: e.username, group: e.group || null })),
          group_winners: appState.tournament?.group_winners || null,
          date: firebase.firestore.FieldValue.serverTimestamp()
        }).then(() => {
          // すべてのFirestoreデータを削除
          const deletePromises = [];
          
          // 大会データを削除
          deletePromises.push(db.collection('tournaments').doc('current').delete());
          
          // エントリーを削除
          deletePromises.push(
            db.collection('entries').get().then(snap => {
              const batch = db.batch();
              snap.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            })
          );
          
          // 試合を削除
          deletePromises.push(
            db.collection('matches').get().then(snap => {
              const batch = db.batch();
              snap.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            })
          );
          
          // ログを削除
          deletePromises.push(
            db.collection('logs').get().then(snap => {
              const batch = db.batch();
              snap.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            })
          );
          
          return Promise.all(deletePromises);
        }).then(() => {
          console.log('全データ削除完了');
          completeEndTournament(champion.username, csvData);
        }).catch(e => {
          console.error('データ削除エラー:', e);
          completeEndTournament(champion.username, csvData);
        });
      } else {
        completeEndTournament(champion.username, csvData);
      }
    }
    
    // 大会終了の完了処理
    function completeEndTournament(championName, csvData) {
      // BGMを通常に戻す
      switchToNormalBGM();

      hideModal('endTournamentModal');
      showToast('大会が終了しました！優勝: ' + championName, 'success');

      // 管理者のみ: CSV自動ダウンロード
      if (csvData) {
        downloadTournamentCSV(csvData.gameName, csvData.adminName, csvData.championName, csvData.entries);
        showToast('参加者名簿CSVをダウンロードしました', 'info');
      }

      // ブラケット表示のボタンを更新（結果を見せたまま）
      const bracketBackBtn = document.getElementById('bracketBackBtn');
      if (bracketBackBtn) {
        bracketBackBtn.textContent = '🏠 タイトルに戻る';
        bracketBackBtn.setAttribute('onclick', 'goToTitleAfterEnd()');
        bracketBackBtn.style.background = 'rgba(40, 30, 0, 0.8)';
        bracketBackBtn.style.borderColor = 'var(--hud-gold)';
        bracketBackBtn.style.color = 'var(--hud-gold)';
        bracketBackBtn.style.boxShadow = '0 0 15px rgba(255, 204, 0, 0.4)';
      }
      const bracketEndBtn = document.getElementById('bracketEndBtn');
      if (bracketEndBtn) {
        bracketEndBtn.disabled = true;
        bracketEndBtn.style.opacity = '0.3';
        bracketEndBtn.style.cursor = 'not-allowed';
        bracketEndBtn.style.background = 'rgba(40,10,20,0.4)';
        bracketEndBtn.style.borderColor = '#555';
        bracketEndBtn.style.color = '#555';
        bracketEndBtn.style.boxShadow = 'none';
      }

      // ルーレット画面のボタンも更新
      const endTournamentBtn = document.getElementById('endTournamentBtn');
      if (endTournamentBtn) {
        endTournamentBtn.textContent = '🏠 タイトルに戻る';
        endTournamentBtn.setAttribute('onclick', 'goToTitleAfterEnd()');
        endTournamentBtn.style.background = 'rgba(40, 30, 0, 0.8)';
        endTournamentBtn.style.borderColor = 'var(--hud-gold)';
        endTournamentBtn.style.color = 'var(--hud-gold)';
        endTournamentBtn.style.boxShadow = '0 0 15px rgba(255, 204, 0, 0.4)';
      }
    }

    // 大会終了後にタイトル画面に戻る
    function goToTitleAfterEnd() {
      tournamentEndedLocally = false;

      // ローカル状態を完全リセット
      appState.tournament = null;
      appState.entries = [];
      appState.matches = [];
      appState.selectedPlayer1 = null;
      appState.selectedPlayer2 = null;
      appState.matchingIds = [];
      appState.activeGroup = null;
      appState.groupPhase = null;
      appState.isAdmin = false;
      appState.adminName = null;
      bracketMode = false;

      // 管理者情報をlocalStorageから削除
      localStorage.removeItem('tournament_admin_name');

      // グループタブを非表示
      const groupTabsEl = document.getElementById('groupTabsContainer');
      if (groupTabsEl) groupTabsEl.style.display = 'none';

      // HUDログをクリア
      hudLogs.length = 0;

      // 画面を更新
      updateTournamentDisplay();
      updateEntriesDisplay();
      updateHudVisibility();

      // 画面履歴をクリア
      screenHistory = [];

      // すべての画面を非表示
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById('titleScreen').classList.add('active');
      currentScreen = 'titleScreen';

      // ヘッダーを非表示
      document.getElementById('mainHeader').classList.remove('visible');
      document.getElementById('backBtn').classList.remove('visible');

      // 抽選会場の状態を完全リセット
      const bracketContainer = document.getElementById('bracketContainer');
      if (bracketContainer) bracketContainer.classList.remove('active');

      const lotteryArena = document.getElementById('lotteryArena');
      if (lotteryArena) {
        lotteryArena.style.display = 'none';
        lotteryArena.style.gridTemplateColumns = '';
      }

      const lotteryEntrance = document.getElementById('lotteryEntrance');
      if (lotteryEntrance) lotteryEntrance.style.display = '';

      const preArenaList = document.getElementById('preArenaList');
      if (preArenaList) preArenaList.style.display = '';

      const rouletteMain = document.querySelector('.lottery-main');
      if (rouletteMain) rouletteMain.style.display = 'flex';

      const lotterySidebar = document.querySelector('.lottery-sidebar');
      if (lotterySidebar) lotterySidebar.style.display = '';

      // ルーレット関連をリセット
      const rouletteAdminControls = document.getElementById('rouletteAdminControls');
      if (rouletteAdminControls) rouletteAdminControls.style.display = 'none';

      const bracketControls = document.getElementById('bracketControls');
      if (bracketControls) bracketControls.style.display = 'none';

      const wheelInner = document.getElementById('wheelInner');
      if (wheelInner) wheelInner.style.transform = 'rotate(0deg)';

      // VS表示をリセット
      updateVsDisplay(null, null);
      disableWinnerSelection();
      updateMatchmakingButton();
      updateHudVisibility();

      // ボタンの状態を元に戻す
      const bracketBackBtn = document.getElementById('bracketBackBtn');
      if (bracketBackBtn) {
        bracketBackBtn.textContent = '🎲 ルーレットに戻る';
        bracketBackBtn.setAttribute('onclick', 'toggleBracketView()');
      }
      const bracketEndBtn = document.getElementById('bracketEndBtn');
      if (bracketEndBtn) {
        bracketEndBtn.disabled = false;
        bracketEndBtn.style.opacity = '';
        bracketEndBtn.style.cursor = '';
        bracketEndBtn.style.display = 'none';
        bracketEndBtn.style.background = 'rgba(40,10,20,0.8)';
        bracketEndBtn.style.borderColor = 'var(--hud-red)';
        bracketEndBtn.style.color = 'var(--hud-red)';
        bracketEndBtn.style.boxShadow = '';
      }
      const endTournamentBtn = document.getElementById('endTournamentBtn');
      if (endTournamentBtn) {
        endTournamentBtn.textContent = '大会終了・記録';
        endTournamentBtn.setAttribute('onclick', 'confirmEndTournament()');
        endTournamentBtn.style.background = 'rgba(40,10,20,0.8)';
        endTournamentBtn.style.borderColor = 'var(--hud-red)';
        endTournamentBtn.style.color = 'var(--hud-red)';
      }
    }
    
    // トーナメントを見るボタンの表示制御（常に表示）
    function updateTournamentViewButton() {
      // 常に表示（参加者リストは見れるようにする）
    }
    function loadHistory() {
      if (!db) { document.getElementById('historyList').innerHTML = '<p style="text-align:center;color:var(--text-dim);">データベース未接続</p>'; return; }
      db.collection('history').orderBy('date', 'desc').get().then(snap => {
        const l = document.getElementById('historyList');
        if (snap.empty) { l.innerHTML = '<p style="text-align:center;color:var(--text-dim);">記録がありません</p>'; return; }
        l.innerHTML = snap.docs.map((d, idx) => {
          const x = d.data();
          const dt = x.date?.toDate?.() || new Date();
          const participants = x.participants || [];
          const participantList = participants.length > 0
            ? '<div id="historyParticipants' + idx + '" style="display:none;margin-top:0.5rem;padding:0.5rem;background:rgba(0,20,10,0.5);border:1px solid var(--hud-green-dim);border-radius:4px;font-size:0.75rem;color:var(--text-dim);max-height:200px;overflow-y:auto;">'
              + participants.map(p => 'ID-' + String(p.entry_id).padStart(2,'0') + ' ' + escapeHtml(p.username)).join('<br>')
              + '</div>'
              + '<div style="margin-top:0.4rem;">'
              + '<button onclick="toggleHistoryParticipants(' + idx + ', this)" style="font-size:0.7rem;padding:0.2rem 0.6rem;background:rgba(0,40,20,0.8);border:1px solid var(--hud-green-dim);color:var(--hud-green);border-radius:4px;cursor:pointer;">▼ 参加者一覧 (' + participants.length + '名)</button>'
              + '</div>'
            : '';
          return '<div class="history-card"><div class="history-date">' + dt.toLocaleDateString('ja-JP') + '</div><div class="history-game">' + escapeHtml(x.game_name || '不明') + '</div><div class="history-winner">👑 優勝: ' + escapeHtml(x.champion_name || '不明') + '</div><div style="font-size:0.8rem;color:var(--text-dim);margin-top:0.4rem;">管理者: ' + escapeHtml(x.admin_name || '不明') + ' / 参加者: ' + (x.total_participants || 0) + '名</div>' + participantList + '</div>';
        }).join('');
      });
    }
    function toggleHistoryParticipants(idx, btn) {
      const el = document.getElementById('historyParticipants' + idx);
      if (!el) return;
      const count = el.querySelectorAll('br').length + 1;
      if (el.style.display === 'none') { el.style.display = 'block'; btn.textContent = '▲ 一覧を閉じる'; }
      else { el.style.display = 'none'; btn.textContent = '▼ 参加者一覧 (' + count + '名)'; }
    }
    // 管理者専用：大会終了時にCSVダウンロード
    function downloadTournamentCSV(gameName, adminName, championName, entries) {
      const now = new Date();
      const year = now.getFullYear();
      const dateStr = now.toLocaleDateString('ja-JP');
      let csv = '\uFEFF';
      csv += '大会日,ゲーム名,管理者,優勝者,参加者数\n';
      csv += '"' + dateStr + '","' + (gameName || '不明') + '","' + (adminName || '不明') + '","' + (championName || '不明') + '",' + entries.length + '\n';
      csv += '\nID,参加者名\n';
      entries.forEach(e => { csv += 'ID-' + String(e.entry_id).padStart(2,'0') + ',"' + e.username + '"\n'; });
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = year + '_' + (gameName || 'tournament') + '_参加者名簿.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    }
    
    // リセット確認
    function confirmResetTournament() {
      // 締切後かつ参加者がいる場合はリセット不可
      const dl = appState.tournament?.deadline;
      if (dl) {
        const d = dl.toDate ? dl.toDate() : new Date(dl);
        if (new Date() >= d && appState.entries.length > 0) {
          showToast('締切日時以降は大会終了までリセットできません', 'error');
          return;
        }
      }
      showModal('resetTournamentModal');
    }
    
    // リセット実行
    async function executeResetTournament() {
      playClick();
      appendLog('⚠️ 管理者が大会をリセットしました');
      
      if (db) {
        // 全データ削除
        try {
          await db.collection('tournaments').doc('current').delete();
          const entriesSnap = await db.collection('entries').get();
          const entriesBatch = db.batch();
          entriesSnap.forEach(doc => entriesBatch.delete(doc.ref));
          await entriesBatch.commit();
          
          const matchesSnap = await db.collection('matches').get();
          const matchesBatch = db.batch();
          matchesSnap.forEach(doc => matchesBatch.delete(doc.ref));
          await matchesBatch.commit();
        } catch (e) { console.error('Reset error:', e); }
      }
      
      // ローカル状態をリセット
      localStorage.removeItem('tournament_admin_name');
      appState.tournament = null;
      appState.entries = [];
      appState.matches = [];
      appState.isAdmin = false;
      appState.adminName = null;
      
      hideModal('resetTournamentModal');
      showToast('大会がリセットされました', 'success');
      
      setTimeout(() => {
        goToTitle();
        updateTournamentDisplay();
      }, 1000);
    }
    
    // リセットボタンの状態更新
    function updateResetButton() {
      const btn = document.getElementById('resetTournamentBtn');
      if (!btn) return;
      const dl = appState.tournament?.deadline;
      if (dl) {
        const d = dl.toDate ? dl.toDate() : new Date(dl);
        if (new Date() >= d) {
          btn.disabled = true;
          btn.style.opacity = '0.3';
        } else {
          btn.disabled = false;
          btn.style.opacity = '';
        }
      }
    }
  </script>
</body>
</html>
